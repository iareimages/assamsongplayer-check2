"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction useSupabaseData() {\n    // Caches for songs and liked songs to avoid repeated cloud fetches\n    const songsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const likedSongsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Personalized songs state (smart sorted, filtered, and history-excluded)\n    const [personalizedSongs, setPersonalizedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Trending songs state (top 15 by views+likes)\n    const [trendingSongs, setTrendingSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [recentlyPlayedSongs, setRecentlyPlayedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Get user ID from localStorage\n    const getUserId = ()=>{\n        try {\n            const userId = localStorage.getItem(\"user_id\");\n            console.log(\"\\uD83D\\uDCF1 Getting user ID from localStorage:\", userId);\n            return userId;\n        } catch (error) {\n            console.error(\"Error getting user ID:\", error);\n            return null;\n        }\n    };\n    // Get personalized songs based on user's actual listening preferences\n    const getSmartPersonalizedSongs = async (userId, listenedSongsInBatch, excludeSongs)=>{\n        try {\n            var _listenedSongsInBatch_;\n            console.log(\"\\uD83E\\uDDE0 Fetching smart personalized songs based on listening behavior\");\n            console.log(\"\\uD83C\\uDFB5 Songs user actually listened to:\", listenedSongsInBatch.map((s)=>s.name));\n            if (listenedSongsInBatch.length === 0) {\n                console.log(\"⚠️ No listened songs in batch, falling back to regular personalization\");\n                return [];\n            }\n            // Extract tags and artists from listened songs\n            const preferredTags = new Set();\n            const preferredArtists = new Set();\n            listenedSongsInBatch.forEach((song)=>{\n                var _song_tags;\n                (_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.forEach((tag)=>preferredTags.add(tag.toLowerCase()));\n                preferredArtists.add(song.artist.toLowerCase());\n            });\n            console.log(\"\\uD83C\\uDFF7️ Preferred tags:\", Array.from(preferredTags));\n            console.log(\"\\uD83C\\uDFA4 Preferred artists:\", Array.from(preferredArtists));\n            // Use cache if available, otherwise fetch and cache\n            let songsData = songsCache.current;\n            if (!songsData) {\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\");\n                if (error) {\n                    console.error(\"❌ Error fetching songs for smart personalization:\", error);\n                    return [];\n                }\n                if (!data || data.length === 0) {\n                    console.warn(\"⚠️ No songs found in database\");\n                    return [];\n                }\n                songsData = data;\n                songsCache.current = data;\n            }\n            let userLikedSongs = likedSongsCache.current;\n            if (!userLikedSongs) {\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n                userLikedSongs = new Set();\n                if (likedData) {\n                    likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n                }\n                likedSongsCache.current = userLikedSongs;\n            }\n            // Filter and score songs based on listening preferences and language\n            // Use the language of the first listened song as the filter\n            const languageFilter = (_listenedSongsInBatch_ = listenedSongsInBatch[0]) === null || _listenedSongsInBatch_ === void 0 ? void 0 : _listenedSongsInBatch_.language;\n            const availableSongs = songsData.filter((song)=>{\n                return !excludeSongs.has(song.file_id.toString()) && song.language === languageFilter;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs for smart recommendations (language: \".concat(languageFilter, \"): \").concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // Score songs based on user's listening preferences\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // High priority: Tag matching with listened songs\n                const songTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.map((tag)=>tag.toLowerCase())) || [];\n                const matchingTags = songTags.filter((tag)=>preferredTags.has(tag));\n                score += matchingTags.length * 25; // Higher weight for tag matching\n                // High priority: Artist matching with listened songs\n                if (preferredArtists.has(song.artist.toLowerCase())) {\n                    score += 30; // Higher weight for artist matching\n                }\n                // Medium priority: Same language as listened songs\n                const listenedLanguages = listenedSongsInBatch.map((s)=>s.language);\n                if (listenedLanguages.includes(song.language)) {\n                    score += 15;\n                }\n                // Lower priority: General popularity\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Bonus for liked songs\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 10;\n                }\n                // Add small randomness to avoid repetition\n                score += Math.random() * 2;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 15) // Get more songs for variety\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83E\\uDDE0 Smart recommendations based on listening behavior:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getSmartPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        const userId = getUserId();\n        console.log(\"\\uD83D\\uDD0D fetchSongs called with userId:\", userId);\n        if (!userId) {\n            console.log(\"❌ No userId found, clearing songs data\");\n            setSongs([]);\n            setPersonalizedSongs([]);\n            setTrendingSongs([]);\n            return;\n        }\n        try {\n            setLoading(true);\n            console.log(\"Fetching all songs from supabase...\");\n            // Test connection first\n            console.log(\"\\uD83D\\uDD17 Testing Supabase connection...\");\n            const { data: testData, error: testError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"count\").limit(1).single();\n            if (testError) {\n                console.error(\"❌ Supabase connection test failed:\", testError);\n                throw new Error(\"Database connection failed: \".concat(testError.message));\n            }\n            console.log(\"✅ Supabase connection successful\");\n            // Fetch songs with simpler query first\n            console.log(\"\\uD83D\\uDCCA Fetching songs data...\");\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\").limit(100) // Start with a smaller limit\n            ;\n            if (error) throw error;\n            if (!songsData || songsData.length === 0) {\n                console.warn(\"⚠️ No songs found in database\");\n                setSongs([]);\n                setPersonalizedSongs([]);\n                setTrendingSongs([]);\n                setLoading(false);\n                return;\n            }\n            console.log(\"✅ Fetched songs:\", songsData.length);\n            // Cache the songs data\n            songsCache.current = songsData;\n            // Fetch liked songs\n            console.log(\"❤️ Fetching liked songs...\");\n            let userLikedSongs = new Set();\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n            if (likedData) {\n                userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                setLikedSongs(userLikedSongs);\n                // Cache liked songs\n                likedSongsCache.current = userLikedSongs;\n            }\n            console.log(\"✅ Fetched liked songs:\", userLikedSongs.size);\n            // Fetch user history (for minutes_listened)\n            console.log(\"\\uD83D\\uDCC8 Fetching user history...\");\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"song_id, minutes_listened, songs(*)\").eq(\"user_id\", userId).order(\"minutes_listened\", {\n                ascending: false\n            }).limit(50) // Limit history to prevent large queries\n            ;\n            if (historyError) {\n                console.warn(\"⚠️ Error fetching history:\", historyError);\n            // Don't throw, continue without history\n            }\n            console.log(\"✅ Fetched user history:\", (historyData === null || historyData === void 0 ? void 0 : historyData.length) || 0);\n            // Get top 15 most listened songs from history\n            const topHistory = (historyData || []).slice(0, 15).filter((h)=>h.songs);\n            // Collect tags and artists from top 15\n            const tagCount = {};\n            const artistCount = {};\n            topHistory.forEach((h)=>{\n                // h.songs may be an array or object, use first if array\n                const songObj = Array.isArray(h.songs) ? h.songs[0] : h.songs;\n                ((songObj === null || songObj === void 0 ? void 0 : songObj.tags) || []).forEach((tag)=>{\n                    const t = tag.toLowerCase();\n                    tagCount[t] = (tagCount[t] || 0) + 1;\n                });\n                if (songObj === null || songObj === void 0 ? void 0 : songObj.artist) {\n                    const a = songObj.artist.toLowerCase();\n                    artistCount[a] = (artistCount[a] || 0) + 1;\n                }\n            });\n            // Find most common tags and artists\n            const commonTags = Object.entries(tagCount).sort((a, b)=>b[1] - a[1]).slice(0, 5).map((param)=>{\n                let [tag] = param;\n                return tag;\n            });\n            const commonArtists = Object.entries(artistCount).sort((a, b)=>b[1] - a[1]).slice(0, 5).map((param)=>{\n                let [artist] = param;\n                return artist;\n            });\n            console.log(\"Found similar tags:\", commonTags);\n            console.log(\"Found similar artists:\", commonArtists);\n            // Songs in history (to exclude for smart sort)\n            const historySongIds = new Set((historyData || []).map((h)=>{\n                var _h_song_id;\n                return (_h_song_id = h.song_id) === null || _h_song_id === void 0 ? void 0 : _h_song_id.toString();\n            }));\n            // Convert all songs\n            const convertedSongs = songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)));\n            console.log(\"✅ Converted songs:\", convertedSongs.length);\n            setSongs(convertedSongs); // songs is now all songs, not personalized\n            // Filter out songs in history for personalized sort\n            const filteredSongs = convertedSongs.filter((song)=>!historySongIds.has(song.id));\n            console.log(\"✅ Filtered songs for personalization:\", filteredSongs.length);\n            // Score songs by tag/artist match\n            const scoredSongs = filteredSongs.map((song)=>{\n                let score = 0;\n                // Tag match\n                const songTags = (song.tags || []).map((t)=>t.toLowerCase());\n                score += songTags.filter((t)=>commonTags.includes(t)).length * 10;\n                // Artist match\n                if (song.artist && commonArtists.includes(song.artist.toLowerCase())) {\n                    score += 20;\n                }\n                // Popularity\n                score += (song.views || 0) + (song.likes || 0);\n                return {\n                    song,\n                    score\n                };\n            });\n            // Sort by score descending\n            const personalizedSorted = scoredSongs.sort((a, b)=>b.score - a.score).map((s)=>s.song);\n            setPersonalizedSongs(personalizedSorted);\n            console.log(\"✅ Set personalized songs:\", personalizedSorted.length);\n            // Trending: top 15 by views+likes (from all songs, including history)\n            const trending = [\n                ...convertedSongs\n            ].sort((a, b)=>b.views + b.likes - (a.views + a.likes)).slice(0, 15);\n            setTrendingSongs(trending);\n            console.log(\"✅ Set trending songs:\", trending.length);\n            // Set last played song as before\n            console.log(\"\\uD83C\\uDFB5 Setting last played song...\");\n            const { data: userData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", userId).single();\n            if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                if (lastSong) {\n                    setLastPlayedSong(lastSong);\n                    console.log(\"✅ Set last played song:\", lastSong.name);\n                }\n            }\n            console.log(\"\\uD83C\\uDF89 Successfully loaded all data!\");\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2, _error_message3;\n            console.error(\"❌ Error fetching songs:\", error);\n            // Show user-friendly error message\n            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"connection\")) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"timeout\"))) {\n                console.error(\"\\uD83C\\uDF10 Connection issue detected\");\n            } else if (((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"permission\")) || ((_error_message3 = error.message) === null || _error_message3 === void 0 ? void 0 : _error_message3.includes(\"auth\"))) {\n                console.error(\"\\uD83D\\uDD10 Authentication issue detected\");\n            }\n            setSongs([]);\n            setPersonalizedSongs([]);\n            setTrendingSongs([]);\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Get personalized songs with proper error handling and filtering\n    const getPersonalizedSongs = async (userId, currentSong, listenedSongs)=>{\n        try {\n            console.log(\"\\uD83C\\uDFB5 Fetching personalized songs for:\", currentSong.name);\n            console.log(\"\\uD83C\\uDFB5 Listened songs count:\", (listenedSongs === null || listenedSongs === void 0 ? void 0 : listenedSongs.size) || 0);\n            // 1. Fetch all songs from cache or cloud\n            let songsData = songsCache.current;\n            if (!songsData) {\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\");\n                if (error) {\n                    console.error(\"❌ Error fetching songs for personalization:\", error);\n                    return [];\n                }\n                if (!data || data.length === 0) {\n                    console.warn(\"⚠️ No songs found in database\");\n                    return [];\n                }\n                songsData = data;\n                songsCache.current = data;\n            }\n            // 2. Fetch user's listening history (not cached, as it may change frequently)\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"song_id, minutes_listened\").eq(\"user_id\", userId);\n            if (historyError) {\n                console.error(\"❌ Error fetching history:\", historyError);\n            }\n            const historyMap = new Map();\n            if (historyData) {\n                historyData.forEach((h)=>historyMap.set(h.song_id, h.minutes_listened || 0));\n            }\n            // 3. Get user's liked songs from cache or cloud\n            let userLikedSongs = likedSongsCache.current;\n            if (!userLikedSongs) {\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n                userLikedSongs = new Set();\n                if (likedData) {\n                    likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n                }\n                likedSongsCache.current = userLikedSongs;\n            }\n            // 4. Filter and score songs (add language filter)\n            const languageFilter = currentSong.language;\n            const availableSongs = songsData.filter((song)=>{\n                // Exclude current song\n                if (song.file_id === currentSong.file_id) {\n                    return false;\n                }\n                // Exclude listened songs if provided\n                if (listenedSongs && listenedSongs.has(song.file_id.toString())) {\n                    console.log(\"\\uD83D\\uDEAB Excluding listened song: \".concat(song.name, \" by \").concat(song.artist));\n                    return false;\n                }\n                // Only include songs with the same language as current song\n                if (song.language !== languageFilter) {\n                    return false;\n                }\n                return true;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs after filtering (language: \".concat(languageFilter, \"): \").concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // 5. Score and sort songs\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // Tag matching (highest priority)\n                const matchingTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.filter((tag)=>{\n                    var _currentSong_tags;\n                    return (_currentSong_tags = currentSong.tags) === null || _currentSong_tags === void 0 ? void 0 : _currentSong_tags.includes(tag);\n                })) || [];\n                score += matchingTags.length * 15;\n                // Artist matching\n                if (song.artist === currentSong.artist) {\n                    score += 25;\n                }\n                // Language matching\n                if (song.language === currentSong.language) {\n                    score += 10;\n                }\n                // Listening history boost\n                const listenedMinutes = historyMap.get(song.file_id) || 0;\n                score += Math.min(listenedMinutes * 2, 20); // Cap at 20 points\n                // Popularity boost (likes and views)\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Liked songs boost\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 8;\n                }\n                // Add controlled randomness to avoid repetition\n                score += Math.random() * 3;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // 6. Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 10) // Get more songs to have a buffer\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83C\\uDFB5 Personalized recommendations:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            console.log(\"\\uD83C\\uDFB5 Total available songs:\", availableSongs.length);\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Fetch recently played songs based on listening history\n    const fetchRecentlyPlayed = async ()=>{\n        const userId = getUserId();\n        if (!userId) {\n            setRecentlyPlayedSongs([]);\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDD0D Fetching recently played songs...\");\n            // Get user's listening history sorted by minutes listened\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"\\n          song_id,\\n          minutes_listened,\\n          songs (*)\\n        \").eq(\"user_id\", userId).order(\"minutes_listened\", {\n                ascending: false\n            }).limit(15) // Increase limit slightly\n            ;\n            if (historyError) {\n                console.warn(\"⚠️ Error fetching recently played:\", historyError);\n                setRecentlyPlayedSongs([]);\n                return;\n            }\n            if (!historyData || historyData.length === 0) {\n                console.log(\"ℹ️ No recently played songs found\");\n                setRecentlyPlayedSongs([]);\n                return;\n            }\n            // Get user's liked songs for proper conversion\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n            const userLikedSongs = new Set();\n            if (likedData) {\n                likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n            }\n            // Convert to Song format\n            const recentSongs = historyData.filter((item)=>item.songs) // Ensure song data exists\n            .map((item)=>{\n                const songObj = Array.isArray(item.songs) ? item.songs[0] : item.songs;\n                return convertDatabaseSong(songObj, userLikedSongs.has(item.song_id));\n            });\n            setRecentlyPlayedSongs(recentSongs);\n            console.log(\"✅ Set recently played songs:\", recentSongs.length);\n        } catch (error) {\n            console.error(\"❌ Error fetching recently played songs:\", error);\n            setRecentlyPlayedSongs([]);\n        }\n    };\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        const userId = getUserId();\n        if (!userId) {\n            setPlaylists([]);\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDD0D Fetching playlists...\");\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", userId).limit(20) // Limit playlists to prevent large queries\n            ;\n            if (error) {\n                console.warn(\"⚠️ Error fetching playlists:\", error);\n                setPlaylists([]);\n                return;\n            }\n            if (!playlistsData) {\n                console.log(\"ℹ️ No playlists found\");\n                setPlaylists([]);\n                return;\n            }\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n            console.log(\"✅ Set playlists:\", convertedPlaylists.length);\n        } catch (error) {\n            console.error(\"❌ Error fetching playlists:\", error);\n            setPlaylists([]);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            if (isCurrentlyLiked) {\n                // Remove from liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", userId).eq(\"song_id\", songFileId);\n                if (error) throw error;\n                // Decrement likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"decrement_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n            } else {\n                // Add to liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").insert({\n                    user_id: userId,\n                    song_id: songFileId\n                });\n                if (error) throw error;\n                // Increment likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"increment_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n            }\n            // Update songs state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        isLiked: !isCurrentlyLiked,\n                        likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                isLiked: !isCurrentlyLiked,\n                                likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").insert({\n                user_id: userId,\n                name\n            }).select().single();\n            if (error) throw error;\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n        } catch (error) {\n            console.error(\"Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", userId);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n        } catch (error) {\n            console.error(\"Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", userId);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n        } catch (error) {\n            console.error(\"Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", userId);\n            if (error) throw error;\n        } catch (error) {\n            console.error(\"Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: userId,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history:\", error);\n                    } else {\n                        console.log(\"✅ History updated: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        // Update last song in user profile\n        await updateLastSong(songId);\n        try {\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"increment_song_views\", {\n                song_file_id: parseInt(songId)\n            });\n        } catch (error) {\n            console.error(\"Error incrementing song views:\", error);\n        }\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        const userId = getUserId();\n        if (currentSongRef.current && currentSongStartTime && userId) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: userId,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history on stop:\", error);\n                    } else {\n                        console.log(\"\\uD83D\\uDED1 History updated on stop: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n    };\n    // Initialize data when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83D\\uDE80 useSupabaseData useEffect triggered\");\n        const userId = getUserId();\n        console.log(\"\\uD83D\\uDC64 Current userId in useEffect:\", userId);\n        if (userId) {\n            const loadDataWithRetry = async function() {\n                let retryCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n                try {\n                    console.log(\"\\uD83D\\uDCCA Loading data for user:\", userId);\n                    console.log(\"\\uD83D\\uDD04 Attempt \".concat(retryCount + 1, \"/3\"));\n                    // Load songs first (most important)\n                    await fetchSongs();\n                    // Then load other data\n                    console.log(\"\\uD83D\\uDCCA Loading additional data...\");\n                    await fetchPlaylists();\n                    await fetchRecentlyPlayed();\n                    console.log(\"\\uD83C\\uDF89 All data loaded successfully!\");\n                } catch (error) {\n                    console.error(\"❌ Error loading data:\", error);\n                    // Retry up to 3 times with exponential backoff\n                    if (retryCount < 2) {\n                        const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s\n                        console.log(\"⏳ Retrying in \".concat(delay, \"ms...\"));\n                        setTimeout(()=>loadDataWithRetry(retryCount + 1), delay);\n                    } else {\n                        console.error(\"❌ Failed to load data after 3 attempts\");\n                        setLoading(false);\n                    }\n                }\n            };\n            loadDataWithRetry();\n        } else {\n            console.log(\"\\uD83D\\uDEAB No user found, resetting data\");\n            // Reset data when no user\n            songsCache.current = null;\n            likedSongsCache.current = null;\n            setSongs([]);\n            setPersonalizedSongs([]);\n            setTrendingSongs([]);\n            setPlaylists([]);\n            setLikedSongs(new Set());\n            setRecentlyPlayedSongs([]);\n            setLastPlayedSong(null);\n            setLoading(false);\n        }\n    }, []) // Remove dependency to avoid infinite loops\n    ;\n    // Also listen for storage changes (when user logs in/out in another tab)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleStorageChange = (e)=>{\n            if (e.key === \"user_id\") {\n                const userId = e.newValue;\n                if (userId) {\n                    console.log(\"\\uD83D\\uDD04 Storage change detected - user logged in:\", userId);\n                    setLoading(true);\n                    const loadData = async ()=>{\n                        try {\n                            await fetchSongs();\n                            await Promise.all([\n                                fetchPlaylists(),\n                                fetchRecentlyPlayed()\n                            ]);\n                        } catch (error) {\n                            console.error(\"❌ Error loading data after storage change:\", error);\n                        } finally{\n                            setLoading(false);\n                        }\n                    };\n                    loadData();\n                } else {\n                    // User logged out\n                    console.log(\"\\uD83D\\uDEAA Storage change detected - user logged out\");\n                    songsCache.current = null;\n                    likedSongsCache.current = null;\n                    setSongs([]);\n                    setPersonalizedSongs([]);\n                    setTrendingSongs([]);\n                    setPlaylists([]);\n                    setLikedSongs(new Set());\n                    setRecentlyPlayedSongs([]);\n                    setLastPlayedSong(null);\n                    setLoading(false);\n                }\n            }\n        };\n        window.addEventListener(\"storage\", handleStorageChange);\n        return ()=>window.removeEventListener(\"storage\", handleStorageChange);\n    }, []);\n    // Add a separate effect to watch for user changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const checkAndLoadData = ()=>{\n            const userId = getUserId();\n            console.log(\"\\uD83D\\uDD04 User check effect triggered, userId:\", userId);\n            if (userId && songs.length === 0 && !loading) {\n                console.log(\"\\uD83D\\uDCCA User found but no songs loaded, loading data...\");\n                const loadData = async ()=>{\n                    try {\n                        await Promise.all([\n                            fetchSongs(),\n                            fetchPlaylists(),\n                            fetchRecentlyPlayed()\n                        ]);\n                    } catch (error) {\n                        console.error(\"Error loading data:\", error);\n                    }\n                };\n                loadData();\n            }\n        };\n        checkAndLoadData();\n    }, [\n        songs.length,\n        loading\n    ]);\n    return {\n        songs,\n        personalizedSongs,\n        trendingSongs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        recentlyPlayedSongs,\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        refreshData: ()=>{\n            const userId = getUserId();\n            if (userId) {\n                console.log(\"\\uD83D\\uDD04 Refreshing data...\");\n                setLoading(true);\n                const loadData = async ()=>{\n                    try {\n                        // Clear caches\n                        songsCache.current = null;\n                        likedSongsCache.current = null;\n                        await fetchSongs();\n                        await Promise.all([\n                            fetchPlaylists(),\n                            fetchRecentlyPlayed()\n                        ]);\n                    } catch (error) {\n                        console.error(\"❌ Error refreshing data:\", error);\n                    } finally{\n                        setLoading(false);\n                    }\n                };\n                loadData();\n            }\n        },\n        getPersonalizedSongs,\n        getSmartPersonalizedSongs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdEO0FBRUo7QUFFN0MsU0FBU0k7SUFDZCxtRUFBbUU7SUFDbkUsTUFBTUMsYUFBYUgsNkNBQU1BLENBQWU7SUFDeEMsTUFBTUksa0JBQWtCSiw2Q0FBTUEsQ0FBcUI7SUFDbkQsTUFBTSxDQUFDSyxPQUFPQyxTQUFTLEdBQUdMLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsMEVBQTBFO0lBQzFFLE1BQU0sQ0FBQ00sbUJBQW1CQyxxQkFBcUIsR0FBR1AsK0NBQVFBLENBQVMsRUFBRTtJQUNyRSwrQ0FBK0M7SUFDL0MsTUFBTSxDQUFDUSxlQUFlQyxpQkFBaUIsR0FBR1QsK0NBQVFBLENBQVMsRUFBRTtJQUM3RCxNQUFNLENBQUNVLFdBQVdDLGFBQWEsR0FBR1gsK0NBQVFBLENBQWEsRUFBRTtJQUN6RCxNQUFNLENBQUNZLFlBQVlDLGNBQWMsR0FBR2IsK0NBQVFBLENBQWMsSUFBSWM7SUFDOUQsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHaEIsK0NBQVFBLENBQWM7SUFDbEUsTUFBTSxDQUFDaUIscUJBQXFCQyx1QkFBdUIsR0FBR2xCLCtDQUFRQSxDQUFTLEVBQUU7SUFDekUsTUFBTSxDQUFDbUIsU0FBU0MsV0FBVyxHQUFHcEIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDcUIsc0JBQXNCQyx3QkFBd0IsR0FBR3RCLCtDQUFRQSxDQUFjO0lBQzlFLE1BQU11QixpQkFBaUJ4Qiw2Q0FBTUEsQ0FBZ0I7SUFFN0MsZ0NBQWdDO0lBQ2hDLE1BQU15QixZQUFZO1FBQ2hCLElBQUk7WUFDRixNQUFNQyxTQUFTQyxhQUFhQyxPQUFPLENBQUM7WUFDcENDLFFBQVFDLEdBQUcsQ0FBQyxtREFBeUNKO1lBQ3JELE9BQU9BO1FBQ1QsRUFBRSxPQUFPSyxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDLE9BQU87UUFDVDtJQUNGO0lBRUEsc0VBQXNFO0lBQ3RFLE1BQU1DLDRCQUE0QixPQUNoQ04sUUFDQU8sc0JBQ0FDO1FBRUEsSUFBSTtnQkFzRHFCRDtZQXJEdkJKLFFBQVFDLEdBQUcsQ0FBQztZQUNaRCxRQUFRQyxHQUFHLENBQUMsaURBQXVDRyxxQkFBcUJFLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSTtZQUV2RixJQUFJSixxQkFBcUJLLE1BQU0sS0FBSyxHQUFHO2dCQUNyQ1QsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU8sRUFBRTtZQUNYO1lBRUEsK0NBQStDO1lBQy9DLE1BQU1TLGdCQUFnQixJQUFJeEI7WUFDMUIsTUFBTXlCLG1CQUFtQixJQUFJekI7WUFFN0JrQixxQkFBcUJRLE9BQU8sQ0FBQ0MsQ0FBQUE7b0JBQzNCQTtpQkFBQUEsYUFBQUEsS0FBS0MsSUFBSSxjQUFURCxpQ0FBQUEsV0FBV0QsT0FBTyxDQUFDRyxDQUFBQSxNQUFPTCxjQUFjTSxHQUFHLENBQUNELElBQUlFLFdBQVc7Z0JBQzNETixpQkFBaUJLLEdBQUcsQ0FBQ0gsS0FBS0ssTUFBTSxDQUFDRCxXQUFXO1lBQzlDO1lBRUFqQixRQUFRQyxHQUFHLENBQUMsaUNBQXVCa0IsTUFBTUMsSUFBSSxDQUFDVjtZQUM5Q1YsUUFBUUMsR0FBRyxDQUFDLG1DQUF5QmtCLE1BQU1DLElBQUksQ0FBQ1Q7WUFFaEQsb0RBQW9EO1lBQ3BELElBQUlVLFlBQVkvQyxXQUFXZ0QsT0FBTztZQUNsQyxJQUFJLENBQUNELFdBQVc7Z0JBQ2QsTUFBTSxFQUFFRSxJQUFJLEVBQUVyQixLQUFLLEVBQUUsR0FBRyxNQUFNakMsbURBQVFBLENBQ25DbUQsSUFBSSxDQUFDLFNBQ0xJLE1BQU0sQ0FBQztnQkFDVixJQUFJdEIsT0FBTztvQkFDVEYsUUFBUUUsS0FBSyxDQUFDLHFEQUFxREE7b0JBQ25FLE9BQU8sRUFBRTtnQkFDWDtnQkFDQSxJQUFJLENBQUNxQixRQUFRQSxLQUFLZCxNQUFNLEtBQUssR0FBRztvQkFDOUJULFFBQVF5QixJQUFJLENBQUM7b0JBQ2IsT0FBTyxFQUFFO2dCQUNYO2dCQUNBSixZQUFZRTtnQkFDWmpELFdBQVdnRCxPQUFPLEdBQUdDO1lBQ3ZCO1lBRUEsSUFBSUcsaUJBQWlCbkQsZ0JBQWdCK0MsT0FBTztZQUM1QyxJQUFJLENBQUNJLGdCQUFnQjtnQkFDbkIsTUFBTSxFQUFFSCxNQUFNSSxTQUFTLEVBQUUsR0FBRyxNQUFNMUQsbURBQVFBLENBQ3ZDbUQsSUFBSSxDQUFDLGVBQ0xJLE1BQU0sQ0FBQyxXQUNQSSxFQUFFLENBQUMsV0FBVy9CO2dCQUNqQjZCLGlCQUFpQixJQUFJeEM7Z0JBQ3JCLElBQUl5QyxXQUFXO29CQUNiQSxVQUFVZixPQUFPLENBQUNpQixDQUFBQSxPQUFRSCxlQUFnQlYsR0FBRyxDQUFDYSxLQUFLQyxPQUFPO2dCQUM1RDtnQkFDQXZELGdCQUFnQitDLE9BQU8sR0FBR0k7WUFDNUI7WUFFQSxxRUFBcUU7WUFDckUsNERBQTREO1lBQzVELE1BQU1LLGtCQUFpQjNCLHlCQUFBQSxvQkFBb0IsQ0FBQyxFQUFFLGNBQXZCQSw2Q0FBQUEsdUJBQXlCNEIsUUFBUTtZQUN4RCxNQUFNQyxpQkFBaUJaLFVBQVVhLE1BQU0sQ0FBQyxDQUFDckI7Z0JBQ3ZDLE9BQ0UsQ0FBQ1IsYUFBYThCLEdBQUcsQ0FBQ3RCLEtBQUt1QixPQUFPLENBQUNDLFFBQVEsT0FDdkN4QixLQUFLbUIsUUFBUSxLQUFLRDtZQUV0QjtZQUVBL0IsUUFBUUMsR0FBRyxDQUFDLHFFQUErRWdDLE9BQXBCRixnQkFBZSxPQUEyQixPQUF0QkUsZUFBZXhCLE1BQU07WUFFaEgsSUFBSXdCLGVBQWV4QixNQUFNLEtBQUssR0FBRztnQkFDL0JULFFBQVF5QixJQUFJLENBQUM7Z0JBQ2IsT0FBTyxFQUFFO1lBQ1g7WUFFQSxvREFBb0Q7WUFDcEQsTUFBTWEsY0FBY0wsZUFBZTNCLEdBQUcsQ0FBQyxDQUFDTztvQkFJckJBO2dCQUhqQixJQUFJMEIsUUFBUTtnQkFFWixrREFBa0Q7Z0JBQ2xELE1BQU1DLFdBQVczQixFQUFBQSxhQUFBQSxLQUFLQyxJQUFJLGNBQVRELGlDQUFBQSxXQUFXUCxHQUFHLENBQUMsQ0FBQ1MsTUFBZ0JBLElBQUlFLFdBQVcsUUFBTyxFQUFFO2dCQUN6RSxNQUFNd0IsZUFBZUQsU0FBU04sTUFBTSxDQUFDLENBQUNuQixNQUFnQkwsY0FBY3lCLEdBQUcsQ0FBQ3BCO2dCQUN4RXdCLFNBQVNFLGFBQWFoQyxNQUFNLEdBQUcsSUFBSSxpQ0FBaUM7Z0JBRXBFLHFEQUFxRDtnQkFDckQsSUFBSUUsaUJBQWlCd0IsR0FBRyxDQUFDdEIsS0FBS0ssTUFBTSxDQUFDRCxXQUFXLEtBQUs7b0JBQ25Ec0IsU0FBUyxJQUFJLG9DQUFvQztnQkFDbkQ7Z0JBRUEsbURBQW1EO2dCQUNuRCxNQUFNRyxvQkFBb0J0QyxxQkFBcUJFLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXlCLFFBQVE7Z0JBQ2xFLElBQUlVLGtCQUFrQkMsUUFBUSxDQUFDOUIsS0FBS21CLFFBQVEsR0FBRztvQkFDN0NPLFNBQVM7Z0JBQ1g7Z0JBRUEscUNBQXFDO2dCQUNyQ0EsU0FBU0ssS0FBSzNDLEdBQUcsQ0FBQyxJQUFLWSxDQUFBQSxLQUFLZ0MsS0FBSyxJQUFJLE1BQU07Z0JBQzNDTixTQUFTSyxLQUFLM0MsR0FBRyxDQUFDLElBQUtZLENBQUFBLEtBQUtpQyxLQUFLLElBQUksTUFBTTtnQkFFM0Msd0JBQXdCO2dCQUN4QixJQUFJcEIsZUFBZVMsR0FBRyxDQUFDdEIsS0FBS3VCLE9BQU8sR0FBRztvQkFDcENHLFNBQVM7Z0JBQ1g7Z0JBRUEsMkNBQTJDO2dCQUMzQ0EsU0FBU0ssS0FBS0csTUFBTSxLQUFLO2dCQUV6QixPQUFPO29CQUNMbEMsTUFBTW1DLG9CQUFvQm5DLE1BQU1hLGVBQWVTLEdBQUcsQ0FBQ3RCLEtBQUt1QixPQUFPO29CQUMvREc7Z0JBQ0Y7WUFDRjtZQUVBLCtDQUErQztZQUMvQyxNQUFNVSxrQkFBa0JYLFlBQ3JCWSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRWIsS0FBSyxHQUFHWSxFQUFFWixLQUFLLEVBQ2hDYyxLQUFLLENBQUMsR0FBRyxJQUFJLDZCQUE2QjthQUMxQy9DLEdBQUcsQ0FBQ2dELENBQUFBLFFBQVNBLE1BQU16QyxJQUFJO1lBRTFCYixRQUFRQyxHQUFHLENBQUMsbUVBQ1ZnRCxnQkFBZ0JJLEtBQUssQ0FBQyxHQUFHLEdBQUcvQyxHQUFHLENBQUNDLENBQUFBLElBQUssR0FBZ0JBLE9BQWJBLEVBQUVDLElBQUksRUFBQyxRQUFlLE9BQVRELEVBQUVXLE1BQU07WUFFL0QsT0FBTytCO1FBRVQsRUFBRSxPQUFPL0MsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMseUNBQXlDQTtZQUN2RCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsMENBQTBDO0lBQzFDLE1BQU04QyxzQkFBc0IsU0FBQ087WUFBc0JDLDJFQUFtQjtlQUFpQjtZQUNyRnBCLFNBQVNtQixPQUFPbkIsT0FBTztZQUN2QnFCLFFBQVFGLE9BQU9FLE1BQU07WUFDckJqRCxNQUFNK0MsT0FBTy9DLElBQUk7WUFDakJVLFFBQVFxQyxPQUFPckMsTUFBTTtZQUNyQmMsVUFBVXVCLE9BQU92QixRQUFRO1lBQ3pCbEIsTUFBTXlDLE9BQU96QyxJQUFJO1lBQ2pCZ0MsT0FBT1MsT0FBT1QsS0FBSztZQUNuQkQsT0FBT1UsT0FBT1YsS0FBSztZQUNuQmEsSUFBSUgsT0FBT25CLE9BQU8sQ0FBQ0MsUUFBUTtZQUMzQnNCLE9BQU8sb0NBQWtFSixPQUE5QkEsT0FBT0UsTUFBTSxFQUFDLGtCQUE4QixPQUFkRixPQUFPRSxNQUFNLEVBQUM7WUFDdkZEO1FBQ0Y7O0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU1JLGFBQWE7UUFDakIsTUFBTS9ELFNBQVNEO1FBQ2ZJLFFBQVFDLEdBQUcsQ0FBQywrQ0FBcUNKO1FBQ2pELElBQUksQ0FBQ0EsUUFBUTtZQUNYRyxRQUFRQyxHQUFHLENBQUM7WUFDWnhCLFNBQVMsRUFBRTtZQUNYRSxxQkFBcUIsRUFBRTtZQUN2QkUsaUJBQWlCLEVBQUU7WUFDbkI7UUFDRjtRQUVBLElBQUk7WUFDRlcsV0FBVztZQUNYUSxRQUFRQyxHQUFHLENBQUM7WUFFWix3QkFBd0I7WUFDeEJELFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRXNCLE1BQU1zQyxRQUFRLEVBQUUzRCxPQUFPNEQsU0FBUyxFQUFFLEdBQUcsTUFBTTdGLG1EQUFRQSxDQUN4RG1ELElBQUksQ0FBQyxTQUNMSSxNQUFNLENBQUMsU0FDUHVDLEtBQUssQ0FBQyxHQUNOQyxNQUFNO1lBRVQsSUFBSUYsV0FBVztnQkFDYjlELFFBQVFFLEtBQUssQ0FBQyxzQ0FBc0M0RDtnQkFDcEQsTUFBTSxJQUFJRyxNQUFNLCtCQUFpRCxPQUFsQkgsVUFBVUksT0FBTztZQUNsRTtZQUVBbEUsUUFBUUMsR0FBRyxDQUFDO1lBRVosdUNBQXVDO1lBQ3ZDRCxRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUVzQixNQUFNRixTQUFTLEVBQUVuQixLQUFLLEVBQUUsR0FBRyxNQUFNakMsbURBQVFBLENBQzlDbUQsSUFBSSxDQUFDLFNBQ0xJLE1BQU0sQ0FBQyxLQUNQdUMsS0FBSyxDQUFDLEtBQUssNkJBQTZCOztZQUUzQyxJQUFJN0QsT0FBTyxNQUFNQTtZQUVqQixJQUFJLENBQUNtQixhQUFhQSxVQUFVWixNQUFNLEtBQUssR0FBRztnQkFDeENULFFBQVF5QixJQUFJLENBQUM7Z0JBQ2JoRCxTQUFTLEVBQUU7Z0JBQ1hFLHFCQUFxQixFQUFFO2dCQUN2QkUsaUJBQWlCLEVBQUU7Z0JBQ25CVyxXQUFXO2dCQUNYO1lBQ0Y7WUFFQVEsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQm9CLFVBQVVaLE1BQU07WUFFaEQsdUJBQXVCO1lBQ3ZCbkMsV0FBV2dELE9BQU8sR0FBR0Q7WUFFckIsb0JBQW9CO1lBQ3BCckIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osSUFBSXlCLGlCQUFpQixJQUFJeEM7WUFDekIsTUFBTSxFQUFFcUMsTUFBTUksU0FBUyxFQUFFLEdBQUcsTUFBTTFELG1EQUFRQSxDQUN2Q21ELElBQUksQ0FBQyxlQUNMSSxNQUFNLENBQUMsV0FDUEksRUFBRSxDQUFDLFdBQVcvQjtZQUNqQixJQUFJOEIsV0FBVztnQkFDYkQsaUJBQWlCLElBQUl4QyxJQUFJeUMsVUFBVXJCLEdBQUcsQ0FBQ3VCLENBQUFBLE9BQVFBLEtBQUtDLE9BQU87Z0JBQzNEN0MsY0FBY3lDO2dCQUNkLG9CQUFvQjtnQkFDcEJuRCxnQkFBZ0IrQyxPQUFPLEdBQUdJO1lBQzVCO1lBQ0ExQixRQUFRQyxHQUFHLENBQUMsMEJBQTBCeUIsZUFBZXlDLElBQUk7WUFFekQsNENBQTRDO1lBQzVDbkUsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFc0IsTUFBTTZDLFdBQVcsRUFBRWxFLE9BQU9tRSxZQUFZLEVBQUUsR0FBRyxNQUFNcEcsbURBQVFBLENBQzlEbUQsSUFBSSxDQUFDLFdBQ0xJLE1BQU0sQ0FBQyx1Q0FDUEksRUFBRSxDQUFDLFdBQVcvQixRQUNkeUUsS0FBSyxDQUFDLG9CQUFvQjtnQkFBRUMsV0FBVztZQUFNLEdBQzdDUixLQUFLLENBQUMsSUFBSSx5Q0FBeUM7O1lBQ3RELElBQUlNLGNBQWM7Z0JBQ2hCckUsUUFBUXlCLElBQUksQ0FBQyw4QkFBOEI0QztZQUMzQyx3Q0FBd0M7WUFDMUM7WUFDQXJFLFFBQVFDLEdBQUcsQ0FBQywyQkFBMkJtRSxDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWEzRCxNQUFNLEtBQUk7WUFFOUQsOENBQThDO1lBQzlDLE1BQU0rRCxhQUFhLENBQUNKLGVBQWUsRUFBRSxFQUFFZixLQUFLLENBQUMsR0FBRyxJQUFJbkIsTUFBTSxDQUFDdUMsQ0FBQUEsSUFBS0EsRUFBRWpHLEtBQUs7WUFDdkUsdUNBQXVDO1lBQ3ZDLE1BQU1rRyxXQUFtQyxDQUFDO1lBQzFDLE1BQU1DLGNBQXNDLENBQUM7WUFDN0NILFdBQVc1RCxPQUFPLENBQUM2RCxDQUFBQTtnQkFDakIsd0RBQXdEO2dCQUN4RCxNQUFNRyxVQUFVekQsTUFBTTBELE9BQU8sQ0FBQ0osRUFBRWpHLEtBQUssSUFBSWlHLEVBQUVqRyxLQUFLLENBQUMsRUFBRSxHQUFHaUcsRUFBRWpHLEtBQUs7Z0JBQzVEb0csQ0FBQUEsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTOUQsSUFBSSxLQUFJLEVBQUUsRUFBRUYsT0FBTyxDQUFDLENBQUNHO29CQUM3QixNQUFNK0QsSUFBSS9ELElBQUlFLFdBQVc7b0JBQ3pCeUQsUUFBUSxDQUFDSSxFQUFFLEdBQUcsQ0FBQ0osUUFBUSxDQUFDSSxFQUFFLElBQUksS0FBSztnQkFDckM7Z0JBQ0EsSUFBSUYsb0JBQUFBLDhCQUFBQSxRQUFTMUQsTUFBTSxFQUFFO29CQUNuQixNQUFNaUMsSUFBSXlCLFFBQVExRCxNQUFNLENBQUNELFdBQVc7b0JBQ3BDMEQsV0FBVyxDQUFDeEIsRUFBRSxHQUFHLENBQUN3QixXQUFXLENBQUN4QixFQUFFLElBQUksS0FBSztnQkFDM0M7WUFDRjtZQUNBLG9DQUFvQztZQUNwQyxNQUFNNEIsYUFBYUMsT0FBT0MsT0FBTyxDQUFDUCxVQUMvQnhCLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxDQUFDLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUMsRUFBRSxFQUMxQkUsS0FBSyxDQUFDLEdBQUcsR0FDVC9DLEdBQUcsQ0FBQztvQkFBQyxDQUFDUyxJQUFJO3VCQUFLQTs7WUFDbEIsTUFBTW1FLGdCQUFnQkYsT0FBT0MsT0FBTyxDQUFDTixhQUNsQ3pCLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxDQUFDLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUMsRUFBRSxFQUMxQkUsS0FBSyxDQUFDLEdBQUcsR0FDVC9DLEdBQUcsQ0FBQztvQkFBQyxDQUFDWSxPQUFPO3VCQUFLQTs7WUFDckJsQixRQUFRQyxHQUFHLENBQUMsdUJBQXVCOEU7WUFDbkMvRSxRQUFRQyxHQUFHLENBQUMsMEJBQTBCaUY7WUFFdEMsK0NBQStDO1lBQy9DLE1BQU1DLGlCQUFpQixJQUFJakcsSUFBSSxDQUFDa0YsZUFBZSxFQUFFLEVBQUU5RCxHQUFHLENBQUNtRSxDQUFBQTtvQkFBS0E7d0JBQUFBLGFBQUFBLEVBQUUzQyxPQUFPLGNBQVQyQyxpQ0FBQUEsV0FBV3BDLFFBQVE7O1lBRS9FLG9CQUFvQjtZQUNwQixNQUFNK0MsaUJBQWlCL0QsVUFBVWYsR0FBRyxDQUFDTyxDQUFBQSxPQUNuQ21DLG9CQUFvQm5DLE1BQU1hLGVBQWVTLEdBQUcsQ0FBQ3RCLEtBQUt1QixPQUFPO1lBRzNEcEMsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQm1GLGVBQWUzRSxNQUFNO1lBRXZEaEMsU0FBUzJHLGlCQUFpQiwyQ0FBMkM7WUFFckUsb0RBQW9EO1lBQ3BELE1BQU1DLGdCQUFnQkQsZUFBZWxELE1BQU0sQ0FBQ3JCLENBQUFBLE9BQVEsQ0FBQ3NFLGVBQWVoRCxHQUFHLENBQUN0QixLQUFLNkMsRUFBRTtZQUMvRTFELFFBQVFDLEdBQUcsQ0FBQyx5Q0FBeUNvRixjQUFjNUUsTUFBTTtZQUV6RSxrQ0FBa0M7WUFDbEMsTUFBTTZCLGNBQWMrQyxjQUFjL0UsR0FBRyxDQUFDTyxDQUFBQTtnQkFDcEMsSUFBSTBCLFFBQVE7Z0JBQ1osWUFBWTtnQkFDWixNQUFNQyxXQUFXLENBQUMzQixLQUFLQyxJQUFJLElBQUksRUFBRSxFQUFFUixHQUFHLENBQUMsQ0FBQ3dFLElBQWNBLEVBQUU3RCxXQUFXO2dCQUNuRXNCLFNBQVNDLFNBQVNOLE1BQU0sQ0FBQzRDLENBQUFBLElBQUtDLFdBQVdwQyxRQUFRLENBQUNtQyxJQUFJckUsTUFBTSxHQUFHO2dCQUMvRCxlQUFlO2dCQUNmLElBQUlJLEtBQUtLLE1BQU0sSUFBSWdFLGNBQWN2QyxRQUFRLENBQUM5QixLQUFLSyxNQUFNLENBQUNELFdBQVcsS0FBSztvQkFDcEVzQixTQUFTO2dCQUNYO2dCQUNBLGFBQWE7Z0JBQ2JBLFNBQVMsQ0FBQzFCLEtBQUtpQyxLQUFLLElBQUksS0FBTWpDLENBQUFBLEtBQUtnQyxLQUFLLElBQUk7Z0JBQzVDLE9BQU87b0JBQUVoQztvQkFBTTBCO2dCQUFNO1lBQ3ZCO1lBQ0EsMkJBQTJCO1lBQzNCLE1BQU0rQyxxQkFBcUJoRCxZQUFZWSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRWIsS0FBSyxHQUFHWSxFQUFFWixLQUFLLEVBQUVqQyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVNLElBQUk7WUFFeEZsQyxxQkFBcUIyRztZQUNyQnRGLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkJxRixtQkFBbUI3RSxNQUFNO1lBRWxFLHNFQUFzRTtZQUN0RSxNQUFNOEUsV0FBVzttQkFBSUg7YUFBZSxDQUNqQ2xDLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLEVBQUdOLEtBQUssR0FBR00sRUFBRVAsS0FBSyxHQUFLTSxDQUFBQSxFQUFFTCxLQUFLLEdBQUdLLEVBQUVOLEtBQUssR0FDdkRRLEtBQUssQ0FBQyxHQUFHO1lBQ1p4RSxpQkFBaUIwRztZQUNqQnZGLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJzRixTQUFTOUUsTUFBTTtZQUVwRCxpQ0FBaUM7WUFDakNULFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRXNCLE1BQU1pRSxRQUFRLEVBQUUsR0FBRyxNQUFNdkgsbURBQVFBLENBQ3RDbUQsSUFBSSxDQUFDLFNBQ0xJLE1BQU0sQ0FBQyxxQkFDUEksRUFBRSxDQUFDLE1BQU0vQixRQUNUbUUsTUFBTTtZQUNULElBQUl3QixxQkFBQUEsK0JBQUFBLFNBQVVDLGlCQUFpQixFQUFFO2dCQUMvQixNQUFNQyxXQUFXTixlQUFlTyxJQUFJLENBQUM5RSxDQUFBQSxPQUFRQSxLQUFLdUIsT0FBTyxLQUFLb0QsU0FBU0MsaUJBQWlCO2dCQUN4RixJQUFJQyxVQUFVO29CQUNadEcsa0JBQWtCc0c7b0JBQ2xCMUYsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQnlGLFNBQVNsRixJQUFJO2dCQUN0RDtZQUNGO1lBRUFSLFFBQVFDLEdBQUcsQ0FBQztRQUNkLEVBQUUsT0FBT0MsT0FBTztnQkFJVkEsZ0JBQXlDQSxpQkFFbENBLGlCQUF5Q0E7WUFMcERGLFFBQVFFLEtBQUssQ0FBQywyQkFBMkJBO1lBRXpDLG1DQUFtQztZQUNuQyxJQUFJQSxFQUFBQSxpQkFBQUEsTUFBTWdFLE9BQU8sY0FBYmhFLHFDQUFBQSxlQUFleUMsUUFBUSxDQUFDLG9CQUFpQnpDLGtCQUFBQSxNQUFNZ0UsT0FBTyxjQUFiaEUsc0NBQUFBLGdCQUFleUMsUUFBUSxDQUFDLGFBQVk7Z0JBQy9FM0MsUUFBUUUsS0FBSyxDQUFDO1lBQ2hCLE9BQU8sSUFBSUEsRUFBQUEsa0JBQUFBLE1BQU1nRSxPQUFPLGNBQWJoRSxzQ0FBQUEsZ0JBQWV5QyxRQUFRLENBQUMsb0JBQWlCekMsa0JBQUFBLE1BQU1nRSxPQUFPLGNBQWJoRSxzQ0FBQUEsZ0JBQWV5QyxRQUFRLENBQUMsVUFBUztnQkFDbkYzQyxRQUFRRSxLQUFLLENBQUM7WUFDaEI7WUFFQXpCLFNBQVMsRUFBRTtZQUNYRSxxQkFBcUIsRUFBRTtZQUN2QkUsaUJBQWlCLEVBQUU7UUFDckIsU0FBVTtZQUNSVyxXQUFXO1FBQ2I7SUFDRjtJQUVBLGtFQUFrRTtJQUNsRSxNQUFNb0csdUJBQXVCLE9BQU8vRixRQUFnQmdHLGFBQW1CQztRQUNyRSxJQUFJO1lBQ0Y5RixRQUFRQyxHQUFHLENBQUMsaURBQXVDNEYsWUFBWXJGLElBQUk7WUFDbkVSLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBNEI2RixDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWUzQixJQUFJLEtBQUk7WUFFL0QseUNBQXlDO1lBQ3pDLElBQUk5QyxZQUFZL0MsV0FBV2dELE9BQU87WUFDbEMsSUFBSSxDQUFDRCxXQUFXO2dCQUNkLE1BQU0sRUFBRUUsSUFBSSxFQUFFckIsS0FBSyxFQUFFLEdBQUcsTUFBTWpDLG1EQUFRQSxDQUNuQ21ELElBQUksQ0FBQyxTQUNMSSxNQUFNLENBQUM7Z0JBQ1YsSUFBSXRCLE9BQU87b0JBQ1RGLFFBQVFFLEtBQUssQ0FBQywrQ0FBK0NBO29CQUM3RCxPQUFPLEVBQUU7Z0JBQ1g7Z0JBQ0EsSUFBSSxDQUFDcUIsUUFBUUEsS0FBS2QsTUFBTSxLQUFLLEdBQUc7b0JBQzlCVCxRQUFReUIsSUFBSSxDQUFDO29CQUNiLE9BQU8sRUFBRTtnQkFDWDtnQkFDQUosWUFBWUU7Z0JBQ1pqRCxXQUFXZ0QsT0FBTyxHQUFHQztZQUN2QjtZQUVBLDhFQUE4RTtZQUM5RSxNQUFNLEVBQUVBLE1BQU02QyxXQUFXLEVBQUVsRSxPQUFPbUUsWUFBWSxFQUFFLEdBQUcsTUFBTXBHLG1EQUFRQSxDQUM5RG1ELElBQUksQ0FBQyxXQUNMSSxNQUFNLENBQUMsNkJBQ1BJLEVBQUUsQ0FBQyxXQUFXL0I7WUFDakIsSUFBSXdFLGNBQWM7Z0JBQ2hCckUsUUFBUUUsS0FBSyxDQUFDLDZCQUE2Qm1FO1lBQzdDO1lBQ0EsTUFBTTBCLGFBQWEsSUFBSUM7WUFDdkIsSUFBSTVCLGFBQWE7Z0JBQ2ZBLFlBQVl4RCxPQUFPLENBQUM2RCxDQUFBQSxJQUFLc0IsV0FBV0UsR0FBRyxDQUFDeEIsRUFBRTNDLE9BQU8sRUFBRTJDLEVBQUV5QixnQkFBZ0IsSUFBSTtZQUMzRTtZQUVBLGdEQUFnRDtZQUNoRCxJQUFJeEUsaUJBQWlCbkQsZ0JBQWdCK0MsT0FBTztZQUM1QyxJQUFJLENBQUNJLGdCQUFnQjtnQkFDbkIsTUFBTSxFQUFFSCxNQUFNSSxTQUFTLEVBQUUsR0FBRyxNQUFNMUQsbURBQVFBLENBQ3ZDbUQsSUFBSSxDQUFDLGVBQ0xJLE1BQU0sQ0FBQyxXQUNQSSxFQUFFLENBQUMsV0FBVy9CO2dCQUNqQjZCLGlCQUFpQixJQUFJeEM7Z0JBQ3JCLElBQUl5QyxXQUFXO29CQUNiQSxVQUFVZixPQUFPLENBQUNpQixDQUFBQSxPQUFRSCxlQUFnQlYsR0FBRyxDQUFDYSxLQUFLQyxPQUFPO2dCQUM1RDtnQkFDQXZELGdCQUFnQitDLE9BQU8sR0FBR0k7WUFDNUI7WUFFQSxrREFBa0Q7WUFDbEQsTUFBTUssaUJBQWlCOEQsWUFBWTdELFFBQVE7WUFDM0MsTUFBTUMsaUJBQWlCWixVQUFVYSxNQUFNLENBQUMsQ0FBQ3JCO2dCQUN2Qyx1QkFBdUI7Z0JBQ3ZCLElBQUlBLEtBQUt1QixPQUFPLEtBQUt5RCxZQUFZekQsT0FBTyxFQUFFO29CQUN4QyxPQUFPO2dCQUNUO2dCQUNBLHFDQUFxQztnQkFDckMsSUFBSTBELGlCQUFpQkEsY0FBYzNELEdBQUcsQ0FBQ3RCLEtBQUt1QixPQUFPLENBQUNDLFFBQVEsS0FBSztvQkFDL0RyQyxRQUFRQyxHQUFHLENBQUMseUNBQStDWSxPQUFoQkEsS0FBS0wsSUFBSSxFQUFDLFFBQWtCLE9BQVpLLEtBQUtLLE1BQU07b0JBQ3RFLE9BQU87Z0JBQ1Q7Z0JBQ0EsNERBQTREO2dCQUM1RCxJQUFJTCxLQUFLbUIsUUFBUSxLQUFLRCxnQkFBZ0I7b0JBQ3BDLE9BQU87Z0JBQ1Q7Z0JBQ0EsT0FBTztZQUNUO1lBRUEvQixRQUFRQyxHQUFHLENBQUMsMkRBQXFFZ0MsT0FBcEJGLGdCQUFlLE9BQTJCLE9BQXRCRSxlQUFleEIsTUFBTTtZQUV0RyxJQUFJd0IsZUFBZXhCLE1BQU0sS0FBSyxHQUFHO2dCQUMvQlQsUUFBUXlCLElBQUksQ0FBQztnQkFDYixPQUFPLEVBQUU7WUFDWDtZQUVBLDBCQUEwQjtZQUMxQixNQUFNYSxjQUFjTCxlQUFlM0IsR0FBRyxDQUFDLENBQUNPO29CQUlqQkE7Z0JBSHJCLElBQUkwQixRQUFRO2dCQUVaLGtDQUFrQztnQkFDbEMsTUFBTUUsZUFBZTVCLEVBQUFBLGFBQUFBLEtBQUtDLElBQUksY0FBVEQsaUNBQUFBLFdBQVdxQixNQUFNLENBQUMsQ0FBQ25CO3dCQUN0QzhFOzRCQUFBQSxvQkFBQUEsWUFBWS9FLElBQUksY0FBaEIrRSx3Q0FBQUEsa0JBQWtCbEQsUUFBUSxDQUFDNUI7dUJBQ3hCLEVBQUU7Z0JBQ1B3QixTQUFTRSxhQUFhaEMsTUFBTSxHQUFHO2dCQUUvQixrQkFBa0I7Z0JBQ2xCLElBQUlJLEtBQUtLLE1BQU0sS0FBSzJFLFlBQVkzRSxNQUFNLEVBQUU7b0JBQ3RDcUIsU0FBUztnQkFDWDtnQkFFQSxvQkFBb0I7Z0JBQ3BCLElBQUkxQixLQUFLbUIsUUFBUSxLQUFLNkQsWUFBWTdELFFBQVEsRUFBRTtvQkFDMUNPLFNBQVM7Z0JBQ1g7Z0JBRUEsMEJBQTBCO2dCQUMxQixNQUFNNEQsa0JBQWtCSixXQUFXSyxHQUFHLENBQUN2RixLQUFLdUIsT0FBTyxLQUFLO2dCQUN4REcsU0FBU0ssS0FBS3lELEdBQUcsQ0FBQ0Ysa0JBQWtCLEdBQUcsS0FBSyxtQkFBbUI7Z0JBRS9ELHFDQUFxQztnQkFDckM1RCxTQUFTSyxLQUFLM0MsR0FBRyxDQUFDLElBQUtZLENBQUFBLEtBQUtnQyxLQUFLLElBQUksTUFBTTtnQkFDM0NOLFNBQVNLLEtBQUszQyxHQUFHLENBQUMsSUFBS1ksQ0FBQUEsS0FBS2lDLEtBQUssSUFBSSxNQUFNO2dCQUUzQyxvQkFBb0I7Z0JBQ3BCLElBQUlwQixlQUFlUyxHQUFHLENBQUN0QixLQUFLdUIsT0FBTyxHQUFHO29CQUNwQ0csU0FBUztnQkFDWDtnQkFFQSxnREFBZ0Q7Z0JBQ2hEQSxTQUFTSyxLQUFLRyxNQUFNLEtBQUs7Z0JBRXpCLE9BQU87b0JBQ0xsQyxNQUFNbUMsb0JBQW9CbkMsTUFBTWEsZUFBZVMsR0FBRyxDQUFDdEIsS0FBS3VCLE9BQU87b0JBQy9ERztnQkFDRjtZQUNGO1lBRUEsa0RBQWtEO1lBQ2xELE1BQU1VLGtCQUFrQlgsWUFDckJZLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFYixLQUFLLEdBQUdZLEVBQUVaLEtBQUssRUFDaENjLEtBQUssQ0FBQyxHQUFHLElBQUksa0NBQWtDO2FBQy9DL0MsR0FBRyxDQUFDZ0QsQ0FBQUEsUUFBU0EsTUFBTXpDLElBQUk7WUFFMUJiLFFBQVFDLEdBQUcsQ0FBQyw4Q0FBb0NnRCxnQkFBZ0JJLEtBQUssQ0FBQyxHQUFHLEdBQUcvQyxHQUFHLENBQUNDLENBQUFBLElBQUssR0FBZ0JBLE9BQWJBLEVBQUVDLElBQUksRUFBQyxRQUFlLE9BQVRELEVBQUVXLE1BQU07WUFDN0dsQixRQUFRQyxHQUFHLENBQUMsdUNBQTZCZ0MsZUFBZXhCLE1BQU07WUFFOUQsT0FBT3dDO1FBRVQsRUFBRSxPQUFPL0MsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsb0NBQW9DQTtZQUNsRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEseURBQXlEO0lBQ3pELE1BQU1vRyxzQkFBc0I7UUFDMUIsTUFBTXpHLFNBQVNEO1FBQ2YsSUFBSSxDQUFDQyxRQUFRO1lBQ1hQLHVCQUF1QixFQUFFO1lBQ3pCO1FBQ0Y7UUFFQSxJQUFJO1lBQ0ZVLFFBQVFDLEdBQUcsQ0FBQztZQUNaLDBEQUEwRDtZQUMxRCxNQUFNLEVBQUVzQixNQUFNNkMsV0FBVyxFQUFFbEUsT0FBT21FLFlBQVksRUFBRSxHQUFHLE1BQU1wRyxtREFBUUEsQ0FDOURtRCxJQUFJLENBQUMsV0FDTEksTUFBTSxDQUFFLG9GQUtSSSxFQUFFLENBQUMsV0FBVy9CLFFBQ2R5RSxLQUFLLENBQUMsb0JBQW9CO2dCQUFFQyxXQUFXO1lBQU0sR0FDN0NSLEtBQUssQ0FBQyxJQUFJLDBCQUEwQjs7WUFFdkMsSUFBSU0sY0FBYztnQkFDaEJyRSxRQUFReUIsSUFBSSxDQUFDLHNDQUFzQzRDO2dCQUNuRC9FLHVCQUF1QixFQUFFO2dCQUN6QjtZQUNGO1lBRUEsSUFBSSxDQUFDOEUsZUFBZUEsWUFBWTNELE1BQU0sS0FBSyxHQUFHO2dCQUM1Q1QsUUFBUUMsR0FBRyxDQUFDO2dCQUNaWCx1QkFBdUIsRUFBRTtnQkFDekI7WUFDRjtZQUVBLCtDQUErQztZQUMvQyxNQUFNLEVBQUVpQyxNQUFNSSxTQUFTLEVBQUUsR0FBRyxNQUFNMUQsbURBQVFBLENBQ3ZDbUQsSUFBSSxDQUFDLGVBQ0xJLE1BQU0sQ0FBQyxXQUNQSSxFQUFFLENBQUMsV0FBVy9CO1lBRWpCLE1BQU02QixpQkFBaUIsSUFBSXhDO1lBQzNCLElBQUl5QyxXQUFXO2dCQUNiQSxVQUFVZixPQUFPLENBQUNpQixDQUFBQSxPQUFRSCxlQUFlVixHQUFHLENBQUNhLEtBQUtDLE9BQU87WUFDM0Q7WUFFQSx5QkFBeUI7WUFDekIsTUFBTXlFLGNBQWNuQyxZQUNqQmxDLE1BQU0sQ0FBQ0wsQ0FBQUEsT0FBUUEsS0FBS3JELEtBQUssRUFBRSwwQkFBMEI7YUFDckQ4QixHQUFHLENBQUN1QixDQUFBQTtnQkFDSCxNQUFNK0MsVUFBVXpELE1BQU0wRCxPQUFPLENBQUNoRCxLQUFLckQsS0FBSyxJQUFJcUQsS0FBS3JELEtBQUssQ0FBQyxFQUFFLEdBQUdxRCxLQUFLckQsS0FBSztnQkFDdEUsT0FBT3dFLG9CQUFvQjRCLFNBQVNsRCxlQUFlUyxHQUFHLENBQUNOLEtBQUtDLE9BQU87WUFDckU7WUFFRnhDLHVCQUF1QmlIO1lBQ3ZCdkcsUUFBUUMsR0FBRyxDQUFDLGdDQUFnQ3NHLFlBQVk5RixNQUFNO1FBQ2hFLEVBQUUsT0FBT1AsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsMkNBQTJDQTtZQUN6RFosdUJBQXVCLEVBQUU7UUFDM0I7SUFDRjtJQUVBLHVCQUF1QjtJQUN2QixNQUFNa0gsaUJBQWlCO1FBQ3JCLE1BQU0zRyxTQUFTRDtRQUNmLElBQUksQ0FBQ0MsUUFBUTtZQUNYZCxhQUFhLEVBQUU7WUFDZjtRQUNGO1FBRUEsSUFBSTtZQUNGaUIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFc0IsTUFBTWtGLGFBQWEsRUFBRXZHLEtBQUssRUFBRSxHQUFHLE1BQU1qQyxtREFBUUEsQ0FDbERtRCxJQUFJLENBQUMsYUFDTEksTUFBTSxDQUFFLDhHQU9SSSxFQUFFLENBQUMsV0FBVy9CLFFBQ2RrRSxLQUFLLENBQUMsSUFBSSwyQ0FBMkM7O1lBRXhELElBQUk3RCxPQUFPO2dCQUNURixRQUFReUIsSUFBSSxDQUFDLGdDQUFnQ3ZCO2dCQUM3Q25CLGFBQWEsRUFBRTtnQkFDZjtZQUNGO1lBRUEsSUFBSSxDQUFDMEgsZUFBZTtnQkFDbEJ6RyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1psQixhQUFhLEVBQUU7Z0JBQ2Y7WUFDRjtZQUVBLE1BQU0ySCxxQkFBaUNELENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZW5HLEdBQUcsQ0FBQ3FHLENBQUFBO29CQUNsQ0EsMEJBUWJDO2dCQVJULE1BQU1BLGdCQUFnQkQsRUFBQUEsMkJBQUFBLFNBQVNFLGNBQWMsY0FBdkJGLCtDQUFBQSx5QkFBeUJyRyxHQUFHLENBQUMsQ0FBQ3dHLEtBQ2xEOUQsb0JBQW9COEQsR0FBR3RJLEtBQUssRUFBRVEsV0FBV21ELEdBQUcsQ0FBQzJFLEdBQUd0SSxLQUFLLENBQUM0RCxPQUFPLFFBQzFELEVBQUU7Z0JBRVAsT0FBTztvQkFDTHNCLElBQUlpRCxTQUFTakQsRUFBRSxDQUFDckIsUUFBUTtvQkFDeEI3QixNQUFNbUcsU0FBU25HLElBQUk7b0JBQ25CdUcsV0FBV0gsY0FBY25HLE1BQU07b0JBQy9Ca0QsT0FBT2lELEVBQUFBLGtCQUFBQSxhQUFhLENBQUMsRUFBRSxjQUFoQkEsc0NBQUFBLGdCQUFrQmpELEtBQUssS0FBSTtvQkFDbENuRixPQUFPb0k7Z0JBQ1Q7WUFDRixPQUFNLEVBQUU7WUFFUjdILGFBQWEySDtZQUNiMUcsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQnlHLG1CQUFtQmpHLE1BQU07UUFDM0QsRUFBRSxPQUFPUCxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDbkIsYUFBYSxFQUFFO1FBQ2pCO0lBQ0Y7SUFFQSxtQkFBbUI7SUFDbkIsTUFBTWlJLGFBQWEsT0FBT0M7UUFDeEIsTUFBTXBILFNBQVNEO1FBQ2YsSUFBSSxDQUFDQyxRQUFRO1FBRWIsTUFBTXFILGFBQWFDLFNBQVNGO1FBQzVCLE1BQU1HLG1CQUFtQnBJLFdBQVdtRCxHQUFHLENBQUMrRTtRQUV4QyxJQUFJO1lBQ0YsSUFBSUUsa0JBQWtCO2dCQUNwQiwwQkFBMEI7Z0JBQzFCLE1BQU0sRUFBRWxILEtBQUssRUFBRSxHQUFHLE1BQU1qQyxtREFBUUEsQ0FDN0JtRCxJQUFJLENBQUMsZUFDTGlHLE1BQU0sR0FDTnpGLEVBQUUsQ0FBQyxXQUFXL0IsUUFDZCtCLEVBQUUsQ0FBQyxXQUFXc0Y7Z0JBRWpCLElBQUloSCxPQUFPLE1BQU1BO2dCQUVqQixrQkFBa0I7Z0JBQ2xCLE1BQU1qQyxtREFBUUEsQ0FBQ3FKLEdBQUcsQ0FBQyx3QkFBd0I7b0JBQUVDLGNBQWNMO2dCQUFXO2dCQUV0RWpJLGNBQWN1SSxDQUFBQTtvQkFDWixNQUFNQyxTQUFTLElBQUl2SSxJQUFJc0k7b0JBQ3ZCQyxPQUFPSixNQUFNLENBQUNIO29CQUNkLE9BQU9PO2dCQUNUO1lBQ0YsT0FBTztnQkFDTCxxQkFBcUI7Z0JBQ3JCLE1BQU0sRUFBRXZILEtBQUssRUFBRSxHQUFHLE1BQU1qQyxtREFBUUEsQ0FDN0JtRCxJQUFJLENBQUMsZUFDTHNHLE1BQU0sQ0FBQztvQkFDTkMsU0FBUzlIO29CQUNUaUMsU0FBU29GO2dCQUNYO2dCQUVGLElBQUloSCxPQUFPLE1BQU1BO2dCQUVqQixrQkFBa0I7Z0JBQ2xCLE1BQU1qQyxtREFBUUEsQ0FBQ3FKLEdBQUcsQ0FBQyx3QkFBd0I7b0JBQUVDLGNBQWNMO2dCQUFXO2dCQUV0RWpJLGNBQWN1SSxDQUFBQSxPQUFRLElBQUl0SSxJQUFJc0ksTUFBTXhHLEdBQUcsQ0FBQ2tHO1lBQzFDO1lBRUEscUJBQXFCO1lBQ3JCekksU0FBU21KLENBQUFBLFlBQ1BBLFVBQVV0SCxHQUFHLENBQUNPLENBQUFBLE9BQ1pBLEtBQUs2QyxFQUFFLEtBQUt1RCxTQUNSO3dCQUNFLEdBQUdwRyxJQUFJO3dCQUNQMkMsU0FBUyxDQUFDNEQ7d0JBQ1Z2RSxPQUFPaEMsS0FBS2dDLEtBQUssR0FBSXVFLENBQUFBLG1CQUFtQixDQUFDLElBQUk7b0JBQy9DLElBQ0F2RztZQUlSLHlCQUF5QjtZQUN6QjlCLGFBQWE4SSxDQUFBQSxnQkFDWEEsY0FBY3ZILEdBQUcsQ0FBQ3FHLENBQUFBLFdBQWE7d0JBQzdCLEdBQUdBLFFBQVE7d0JBQ1huSSxPQUFPbUksU0FBU25JLEtBQUssQ0FBQzhCLEdBQUcsQ0FBQ08sQ0FBQUEsT0FDeEJBLEtBQUs2QyxFQUFFLEtBQUt1RCxTQUNSO2dDQUNFLEdBQUdwRyxJQUFJO2dDQUNQMkMsU0FBUyxDQUFDNEQ7Z0NBQ1Z2RSxPQUFPaEMsS0FBS2dDLEtBQUssR0FBSXVFLENBQUFBLG1CQUFtQixDQUFDLElBQUk7NEJBQy9DLElBQ0F2RztvQkFFUjtRQUVKLEVBQUUsT0FBT1gsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsd0JBQXdCQTtRQUN4QztJQUNGO0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU00SCxpQkFBaUIsT0FBT3RIO1FBQzVCLE1BQU1YLFNBQVNEO1FBQ2YsSUFBSSxDQUFDQyxRQUFRO1FBRWIsSUFBSTtZQUNGLE1BQU0sRUFBRTBCLElBQUksRUFBRXJCLEtBQUssRUFBRSxHQUFHLE1BQU1qQyxtREFBUUEsQ0FDbkNtRCxJQUFJLENBQUMsYUFDTHNHLE1BQU0sQ0FBQztnQkFDTkMsU0FBUzlIO2dCQUNUVztZQUNGLEdBQ0NnQixNQUFNLEdBQ053QyxNQUFNO1lBRVQsSUFBSTlELE9BQU8sTUFBTUE7WUFFakIsTUFBTTZILGNBQXdCO2dCQUM1QnJFLElBQUluQyxLQUFLbUMsRUFBRSxDQUFDckIsUUFBUTtnQkFDcEI3QixNQUFNZSxLQUFLZixJQUFJO2dCQUNmdUcsV0FBVztnQkFDWHBELE9BQU87Z0JBQ1BuRixPQUFPLEVBQUU7WUFDWDtZQUVBTyxhQUFheUksQ0FBQUEsT0FBUTt1QkFBSUE7b0JBQU1PO2lCQUFZO1FBQzdDLEVBQUUsT0FBTzdILE9BQU87WUFDZEYsUUFBUUUsS0FBSyxDQUFDLDRCQUE0QkE7UUFDNUM7SUFDRjtJQUVBLGtCQUFrQjtJQUNsQixNQUFNOEgsaUJBQWlCLE9BQU9DO1FBQzVCLE1BQU1wSSxTQUFTRDtRQUNmLElBQUksQ0FBQ0MsUUFBUTtRQUViLElBQUk7WUFDRixNQUFNLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1qQyxtREFBUUEsQ0FDN0JtRCxJQUFJLENBQUMsYUFDTGlHLE1BQU0sR0FDTnpGLEVBQUUsQ0FBQyxNQUFNdUYsU0FBU2MsYUFDbEJyRyxFQUFFLENBQUMsV0FBVy9CO1lBRWpCLElBQUlLLE9BQU8sTUFBTUE7WUFFakJuQixhQUFheUksQ0FBQUEsT0FBUUEsS0FBS3RGLE1BQU0sQ0FBQ3lFLENBQUFBLFdBQVlBLFNBQVNqRCxFQUFFLEtBQUt1RTtRQUMvRCxFQUFFLE9BQU8vSCxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzVDO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTWdJLGlCQUFpQixPQUFPRCxZQUFvQkU7UUFDaEQsTUFBTXRJLFNBQVNEO1FBQ2YsSUFBSSxDQUFDQyxRQUFRO1FBRWIsSUFBSTtZQUNGLE1BQU0sRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTWpDLG1EQUFRQSxDQUM3Qm1ELElBQUksQ0FBQyxhQUNMZ0gsTUFBTSxDQUFDO2dCQUFFNUgsTUFBTTJIO1lBQVEsR0FDdkJ2RyxFQUFFLENBQUMsTUFBTXVGLFNBQVNjLGFBQ2xCckcsRUFBRSxDQUFDLFdBQVcvQjtZQUVqQixJQUFJSyxPQUFPLE1BQU1BO1lBRWpCbkIsYUFBYXlJLENBQUFBLE9BQ1hBLEtBQUtsSCxHQUFHLENBQUNxRyxDQUFBQSxXQUNQQSxTQUFTakQsRUFBRSxLQUFLdUUsYUFDWjt3QkFBRSxHQUFHdEIsUUFBUTt3QkFBRW5HLE1BQU0ySDtvQkFBUSxJQUM3QnhCO1FBR1YsRUFBRSxPQUFPekcsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsNEJBQTRCQTtRQUM1QztJQUNGO0lBRUEsdUJBQXVCO0lBQ3ZCLE1BQU1tSSxvQkFBb0IsT0FBT0osWUFBb0JwSDtRQUNuRCxNQUFNaEIsU0FBU0Q7UUFDZixJQUFJLENBQUNDLFFBQVE7UUFFYixJQUFJO1lBQ0YsTUFBTSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNakMsbURBQVFBLENBQzdCbUQsSUFBSSxDQUFDLGtCQUNMc0csTUFBTSxDQUFDO2dCQUNOWSxhQUFhbkIsU0FBU2M7Z0JBQ3RCbkcsU0FBU2pCLEtBQUt1QixPQUFPO1lBQ3ZCO1lBRUYsSUFBSWxDLE9BQU8sTUFBTUE7WUFFakJuQixhQUFheUksQ0FBQUEsT0FDWEEsS0FBS2xILEdBQUcsQ0FBQ3FHLENBQUFBO29CQUNQLElBQUlBLFNBQVNqRCxFQUFFLEtBQUt1RSxZQUFZO3dCQUM5QixNQUFNTSxhQUFhNUIsU0FBU25JLEtBQUssQ0FBQ2dLLElBQUksQ0FBQ2pJLENBQUFBLElBQUtBLEVBQUVtRCxFQUFFLEtBQUs3QyxLQUFLNkMsRUFBRTt3QkFDNUQsSUFBSSxDQUFDNkUsWUFBWTtnQ0FNTkU7NEJBTFQsTUFBTUEsZUFBZTttQ0FBSTlCLFNBQVNuSSxLQUFLO2dDQUFFcUM7NkJBQUs7NEJBQzlDLE9BQU87Z0NBQ0wsR0FBRzhGLFFBQVE7Z0NBQ1huSSxPQUFPaUs7Z0NBQ1AxQixXQUFXMEIsYUFBYWhJLE1BQU07Z0NBQzlCa0QsT0FBTzhFLEVBQUFBLGlCQUFBQSxZQUFZLENBQUMsRUFBRSxjQUFmQSxxQ0FBQUEsZUFBaUI5RSxLQUFLLEtBQUlnRCxTQUFTaEQsS0FBSzs0QkFDakQ7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsT0FBT2dEO2dCQUNUO1FBRUosRUFBRSxPQUFPekcsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsa0NBQWtDQTtRQUNsRDtJQUNGO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU13SSx5QkFBeUIsT0FBT1QsWUFBb0JoQjtRQUN4RCxNQUFNcEgsU0FBU0Q7UUFDZixJQUFJLENBQUNDLFFBQVE7UUFFYixJQUFJO1lBQ0YsTUFBTSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNakMsbURBQVFBLENBQzdCbUQsSUFBSSxDQUFDLGtCQUNMaUcsTUFBTSxHQUNOekYsRUFBRSxDQUFDLGVBQWV1RixTQUFTYyxhQUMzQnJHLEVBQUUsQ0FBQyxXQUFXdUYsU0FBU0Y7WUFFMUIsSUFBSS9HLE9BQU8sTUFBTUE7WUFFakJuQixhQUFheUksQ0FBQUEsT0FDWEEsS0FBS2xILEdBQUcsQ0FBQ3FHLENBQUFBO29CQUNQLElBQUlBLFNBQVNqRCxFQUFFLEtBQUt1RSxZQUFZOzRCQU1yQlE7d0JBTFQsTUFBTUEsZUFBZTlCLFNBQVNuSSxLQUFLLENBQUMwRCxNQUFNLENBQUNyQixDQUFBQSxPQUFRQSxLQUFLNkMsRUFBRSxLQUFLdUQ7d0JBQy9ELE9BQU87NEJBQ0wsR0FBR04sUUFBUTs0QkFDWG5JLE9BQU9pSzs0QkFDUDFCLFdBQVcwQixhQUFhaEksTUFBTTs0QkFDOUJrRCxPQUFPOEUsRUFBQUEsaUJBQUFBLFlBQVksQ0FBQyxFQUFFLGNBQWZBLHFDQUFBQSxlQUFpQjlFLEtBQUssS0FBSTt3QkFDbkM7b0JBQ0Y7b0JBQ0EsT0FBT2dEO2dCQUNUO1FBRUosRUFBRSxPQUFPekcsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsc0NBQXNDQTtRQUN0RDtJQUNGO0lBRUEsbUNBQW1DO0lBQ25DLE1BQU15SSxpQkFBaUIsT0FBTzFCO1FBQzVCLE1BQU1wSCxTQUFTRDtRQUNmLElBQUksQ0FBQ0MsUUFBUTtRQUViLElBQUk7WUFDRixNQUFNLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1qQyxtREFBUUEsQ0FDN0JtRCxJQUFJLENBQUMsU0FDTGdILE1BQU0sQ0FBQztnQkFBRTNDLG1CQUFtQjBCLFNBQVNGO1lBQVEsR0FDN0NyRixFQUFFLENBQUMsTUFBTS9CO1lBRVosSUFBSUssT0FBTyxNQUFNQTtRQUNuQixFQUFFLE9BQU9BLE9BQU87WUFDZEYsUUFBUUUsS0FBSyxDQUFDLDZCQUE2QkE7UUFDN0M7SUFDRjtJQUVBLHFEQUFxRDtJQUNyRCxNQUFNMEkseUJBQXlCLE9BQU8zQjtRQUNwQyxNQUFNcEgsU0FBU0Q7UUFDZixJQUFJLENBQUNDLFFBQVE7UUFFYixnRUFBZ0U7UUFDaEUsSUFBSUYsZUFBZTJCLE9BQU8sSUFBSTdCLHNCQUFzQjtZQUNsRCxNQUFNb0osVUFBVSxJQUFJQztZQUNwQixNQUFNQyxrQkFBa0IsQ0FBQ0YsUUFBUUcsT0FBTyxLQUFLdkoscUJBQXFCdUosT0FBTyxFQUFDLElBQU0sUUFBTyxFQUFDO1lBRXhGLElBQUlELGtCQUFrQixLQUFLO2dCQUN6QixJQUFJO29CQUNGLE1BQU1FLFVBQVVyRyxLQUFLc0csS0FBSyxDQUFDSCxrQkFBa0IsT0FBTztvQkFDcEQsTUFBTSxFQUFFN0ksS0FBSyxFQUFFLEdBQUcsTUFBTWpDLG1EQUFRQSxDQUFDcUosR0FBRyxDQUFDLDBCQUEwQjt3QkFDN0Q2QixXQUFXdEo7d0JBQ1gwSCxjQUFjSixTQUFTeEgsZUFBZTJCLE9BQU87d0JBQzdDMkgsU0FBU0E7b0JBQ1g7b0JBRUEsSUFBSS9JLE9BQU87d0JBQ1RGLFFBQVFFLEtBQUssQ0FBQyxtQ0FBbUNBO29CQUNuRCxPQUFPO3dCQUNMRixRQUFRQyxHQUFHLENBQUMsdUJBQWdETixPQUF6QnNKLFNBQVEsbUJBQXdDLE9BQXZCdEosZUFBZTJCLE9BQU87b0JBQ3BGO2dCQUNGLEVBQUUsT0FBT3BCLE9BQU87b0JBQ2RGLFFBQVFFLEtBQUssQ0FBQywwQ0FBMENBO2dCQUMxRDtZQUNGO1FBQ0Y7UUFFQSwwQkFBMEI7UUFDMUJQLGVBQWUyQixPQUFPLEdBQUcyRjtRQUN6QnZILHdCQUF3QixJQUFJb0o7UUFFNUIsbUNBQW1DO1FBQ25DLE1BQU1ILGVBQWUxQjtRQUNyQixJQUFJO1lBQ0YsTUFBTWhKLG1EQUFRQSxDQUFDcUosR0FBRyxDQUFDLHdCQUF3QjtnQkFBRUMsY0FBY0osU0FBU0Y7WUFBUTtRQUM5RSxFQUFFLE9BQU8vRyxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2xEO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDckQsTUFBTWtKLDBCQUEwQjtRQUM5QixNQUFNdkosU0FBU0Q7UUFDZixJQUFJRCxlQUFlMkIsT0FBTyxJQUFJN0Isd0JBQXdCSSxRQUFRO1lBQzVELE1BQU1nSixVQUFVLElBQUlDO1lBQ3BCLE1BQU1DLGtCQUFrQixDQUFDRixRQUFRRyxPQUFPLEtBQUt2SixxQkFBcUJ1SixPQUFPLEVBQUMsSUFBTSxRQUFPLEVBQUM7WUFFeEYsSUFBSUQsa0JBQWtCLEtBQUs7Z0JBQ3pCLElBQUk7b0JBQ0YsTUFBTUUsVUFBVXJHLEtBQUtzRyxLQUFLLENBQUNILGtCQUFrQixPQUFPO29CQUNwRCxNQUFNLEVBQUU3SSxLQUFLLEVBQUUsR0FBRyxNQUFNakMsbURBQVFBLENBQUNxSixHQUFHLENBQUMsMEJBQTBCO3dCQUM3RDZCLFdBQVd0Sjt3QkFDWDBILGNBQWNKLFNBQVN4SCxlQUFlMkIsT0FBTzt3QkFDN0MySCxTQUFTQTtvQkFDWDtvQkFFQSxJQUFJL0ksT0FBTzt3QkFDVEYsUUFBUUUsS0FBSyxDQUFDLDJDQUEyQ0E7b0JBQzNELE9BQU87d0JBQ0xGLFFBQVFDLEdBQUcsQ0FBQywwQ0FBeUROLE9BQXpCc0osU0FBUSxtQkFBd0MsT0FBdkJ0SixlQUFlMkIsT0FBTztvQkFDN0Y7Z0JBQ0YsRUFBRSxPQUFPcEIsT0FBTztvQkFDZEYsUUFBUUUsS0FBSyxDQUFDLHVDQUF1Q0E7Z0JBQ3ZEO1lBQ0Y7UUFDRjtRQUVBUCxlQUFlMkIsT0FBTyxHQUFHO1FBQ3pCNUIsd0JBQXdCO0lBQzFCO0lBRUEsd0NBQXdDO0lBQ3hDeEIsZ0RBQVNBLENBQUM7UUFDUjhCLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE1BQU1KLFNBQVNEO1FBQ2ZJLFFBQVFDLEdBQUcsQ0FBQyw2Q0FBbUNKO1FBQy9DLElBQUlBLFFBQVE7WUFDVixNQUFNd0osb0JBQW9CO29CQUFPQyw4RUFBYTtnQkFDNUMsSUFBSTtvQkFDRnRKLFFBQVFDLEdBQUcsQ0FBQyx1Q0FBNkJKO29CQUN6Q0csUUFBUUMsR0FBRyxDQUFDLHdCQUE2QixPQUFmcUosYUFBYSxHQUFFO29CQUV6QyxvQ0FBb0M7b0JBQ3BDLE1BQU0xRjtvQkFFTix1QkFBdUI7b0JBQ3ZCNUQsUUFBUUMsR0FBRyxDQUFDO29CQUNaLE1BQU11RztvQkFDTixNQUFNRjtvQkFFTnRHLFFBQVFDLEdBQUcsQ0FBQztnQkFDZCxFQUFFLE9BQU9DLE9BQU87b0JBQ2RGLFFBQVFFLEtBQUssQ0FBQyx5QkFBeUJBO29CQUV2QywrQ0FBK0M7b0JBQy9DLElBQUlvSixhQUFhLEdBQUc7d0JBQ2xCLE1BQU1DLFFBQVEzRyxLQUFLNEcsR0FBRyxDQUFDLEdBQUdGLGNBQWMsTUFBTSxhQUFhO3dCQUMzRHRKLFFBQVFDLEdBQUcsQ0FBQyxpQkFBdUIsT0FBTnNKLE9BQU07d0JBQ25DRSxXQUFXLElBQU1KLGtCQUFrQkMsYUFBYSxJQUFJQztvQkFDdEQsT0FBTzt3QkFDTHZKLFFBQVFFLEtBQUssQ0FBQzt3QkFDZFYsV0FBVztvQkFDYjtnQkFDRjtZQUNGO1lBQ0E2SjtRQUNGLE9BQU87WUFDTHJKLFFBQVFDLEdBQUcsQ0FBQztZQUNaLDBCQUEwQjtZQUMxQjNCLFdBQVdnRCxPQUFPLEdBQUc7WUFDckIvQyxnQkFBZ0IrQyxPQUFPLEdBQUc7WUFDMUI3QyxTQUFTLEVBQUU7WUFDWEUscUJBQXFCLEVBQUU7WUFDdkJFLGlCQUFpQixFQUFFO1lBQ25CRSxhQUFhLEVBQUU7WUFDZkUsY0FBYyxJQUFJQztZQUNsQkksdUJBQXVCLEVBQUU7WUFDekJGLGtCQUFrQjtZQUNsQkksV0FBVztRQUNiO0lBQ0YsR0FBRyxFQUFFLEVBQUUsNENBQTRDOztJQUVuRCx5RUFBeUU7SUFDekV0QixnREFBU0EsQ0FBQztRQUNSLE1BQU13TCxzQkFBc0IsQ0FBQ0M7WUFDM0IsSUFBSUEsRUFBRUMsR0FBRyxLQUFLLFdBQVc7Z0JBQ3ZCLE1BQU0vSixTQUFTOEosRUFBRUUsUUFBUTtnQkFDekIsSUFBSWhLLFFBQVE7b0JBQ1ZHLFFBQVFDLEdBQUcsQ0FBQywwREFBZ0RKO29CQUM1REwsV0FBVztvQkFDWCxNQUFNc0ssV0FBVzt3QkFDZixJQUFJOzRCQUNGLE1BQU1sRzs0QkFDTixNQUFNbUcsUUFBUUMsR0FBRyxDQUFDO2dDQUFDeEQ7Z0NBQWtCRjs2QkFBc0I7d0JBQzdELEVBQUUsT0FBT3BHLE9BQU87NEJBQ2RGLFFBQVFFLEtBQUssQ0FBQyw4Q0FBOENBO3dCQUM5RCxTQUFVOzRCQUNSVixXQUFXO3dCQUNiO29CQUNGO29CQUNBc0s7Z0JBQ0YsT0FBTztvQkFDTCxrQkFBa0I7b0JBQ2xCOUosUUFBUUMsR0FBRyxDQUFDO29CQUNaM0IsV0FBV2dELE9BQU8sR0FBRztvQkFDckIvQyxnQkFBZ0IrQyxPQUFPLEdBQUc7b0JBQzFCN0MsU0FBUyxFQUFFO29CQUNYRSxxQkFBcUIsRUFBRTtvQkFDdkJFLGlCQUFpQixFQUFFO29CQUNuQkUsYUFBYSxFQUFFO29CQUNmRSxjQUFjLElBQUlDO29CQUNsQkksdUJBQXVCLEVBQUU7b0JBQ3pCRixrQkFBa0I7b0JBQ2xCSSxXQUFXO2dCQUNiO1lBQ0Y7UUFDRjtRQUVBeUssT0FBT0MsZ0JBQWdCLENBQUMsV0FBV1I7UUFDbkMsT0FBTyxJQUFNTyxPQUFPRSxtQkFBbUIsQ0FBQyxXQUFXVDtJQUNyRCxHQUFHLEVBQUU7SUFFTCxrREFBa0Q7SUFDbER4TCxnREFBU0EsQ0FBQztRQUNSLE1BQU1rTSxtQkFBbUI7WUFDdkIsTUFBTXZLLFNBQVNEO1lBQ2ZJLFFBQVFDLEdBQUcsQ0FBQyxxREFBMkNKO1lBQ3ZELElBQUlBLFVBQVVyQixNQUFNaUMsTUFBTSxLQUFLLEtBQUssQ0FBQ2xCLFNBQVM7Z0JBQzVDUyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osTUFBTTZKLFdBQVc7b0JBQ2YsSUFBSTt3QkFDRixNQUFNQyxRQUFRQyxHQUFHLENBQUM7NEJBQUNwRzs0QkFBYzRDOzRCQUFrQkY7eUJBQXNCO29CQUMzRSxFQUFFLE9BQU9wRyxPQUFPO3dCQUNkRixRQUFRRSxLQUFLLENBQUMsdUJBQXVCQTtvQkFDdkM7Z0JBQ0Y7Z0JBQ0E0SjtZQUNGO1FBQ0Y7UUFDQU07SUFDRixHQUFHO1FBQUM1TCxNQUFNaUMsTUFBTTtRQUFFbEI7S0FBUTtJQUMxQixPQUFPO1FBQ0xmO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFLFlBQVlSLE1BQU0wRCxNQUFNLENBQUNyQixDQUFBQSxPQUFRQSxLQUFLMkMsT0FBTztRQUM3Q25FO1FBQ0FGO1FBQ0FJO1FBQ0F5SDtRQUNBYztRQUNBRTtRQUNBRTtRQUNBRztRQUNBSztRQUNBRTtRQUNBUTtRQUNBaUIsYUFBYTtZQUNYLE1BQU14SyxTQUFTRDtZQUNmLElBQUlDLFFBQVE7Z0JBQ1ZHLFFBQVFDLEdBQUcsQ0FBQztnQkFDWlQsV0FBVztnQkFDWCxNQUFNc0ssV0FBVztvQkFDZixJQUFJO3dCQUNGLGVBQWU7d0JBQ2Z4TCxXQUFXZ0QsT0FBTyxHQUFHO3dCQUNyQi9DLGdCQUFnQitDLE9BQU8sR0FBRzt3QkFDMUIsTUFBTXNDO3dCQUNOLE1BQU1tRyxRQUFRQyxHQUFHLENBQUM7NEJBQUN4RDs0QkFBa0JGO3lCQUFzQjtvQkFDN0QsRUFBRSxPQUFPcEcsT0FBTzt3QkFDZEYsUUFBUUUsS0FBSyxDQUFDLDRCQUE0QkE7b0JBQzVDLFNBQVU7d0JBQ1JWLFdBQVc7b0JBQ2I7Z0JBQ0Y7Z0JBQ0FzSztZQUNGO1FBQ0Y7UUFDQWxFO1FBQ0F6RjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlU3VwYWJhc2VEYXRhLnRzP2FiZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YWJhc2VTb25nLCBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcbmltcG9ydCB7IFBsYXlsaXN0LCBTb25nIH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdXBhYmFzZURhdGEoKSB7XG4gIC8vIENhY2hlcyBmb3Igc29uZ3MgYW5kIGxpa2VkIHNvbmdzIHRvIGF2b2lkIHJlcGVhdGVkIGNsb3VkIGZldGNoZXNcbiAgY29uc3Qgc29uZ3NDYWNoZSA9IHVzZVJlZjxhbnlbXSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsaWtlZFNvbmdzQ2FjaGUgPSB1c2VSZWY8U2V0PG51bWJlcj4gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3NvbmdzLCBzZXRTb25nc10gPSB1c2VTdGF0ZTxTb25nW10+KFtdKVxuICAvLyBQZXJzb25hbGl6ZWQgc29uZ3Mgc3RhdGUgKHNtYXJ0IHNvcnRlZCwgZmlsdGVyZWQsIGFuZCBoaXN0b3J5LWV4Y2x1ZGVkKVxuICBjb25zdCBbcGVyc29uYWxpemVkU29uZ3MsIHNldFBlcnNvbmFsaXplZFNvbmdzXSA9IHVzZVN0YXRlPFNvbmdbXT4oW10pXG4gIC8vIFRyZW5kaW5nIHNvbmdzIHN0YXRlICh0b3AgMTUgYnkgdmlld3MrbGlrZXMpXG4gIGNvbnN0IFt0cmVuZGluZ1NvbmdzLCBzZXRUcmVuZGluZ1NvbmdzXSA9IHVzZVN0YXRlPFNvbmdbXT4oW10pXG4gIGNvbnN0IFtwbGF5bGlzdHMsIHNldFBsYXlsaXN0c10gPSB1c2VTdGF0ZTxQbGF5bGlzdFtdPihbXSlcbiAgY29uc3QgW2xpa2VkU29uZ3MsIHNldExpa2VkU29uZ3NdID0gdXNlU3RhdGU8U2V0PG51bWJlcj4+KG5ldyBTZXQoKSlcbiAgY29uc3QgW2xhc3RQbGF5ZWRTb25nLCBzZXRMYXN0UGxheWVkU29uZ10gPSB1c2VTdGF0ZTxTb25nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW3JlY2VudGx5UGxheWVkU29uZ3MsIHNldFJlY2VudGx5UGxheWVkU29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtjdXJyZW50U29uZ1N0YXJ0VGltZSwgc2V0Q3VycmVudFNvbmdTdGFydFRpbWVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGN1cnJlbnRTb25nUmVmID0gdXNlUmVmPHN0cmluZyB8IG51bGw+KG51bGwpXG5cbiAgLy8gR2V0IHVzZXIgSUQgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgZ2V0VXNlcklkID0gKCk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VySWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcl9pZCcpXG4gICAgICBjb25zb2xlLmxvZygn8J+TsSBHZXR0aW5nIHVzZXIgSUQgZnJvbSBsb2NhbFN0b3JhZ2U6JywgdXNlcklkKVxuICAgICAgcmV0dXJuIHVzZXJJZFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgSUQ6JywgZXJyb3IpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBwZXJzb25hbGl6ZWQgc29uZ3MgYmFzZWQgb24gdXNlcidzIGFjdHVhbCBsaXN0ZW5pbmcgcHJlZmVyZW5jZXNcbiAgY29uc3QgZ2V0U21hcnRQZXJzb25hbGl6ZWRTb25ncyA9IGFzeW5jIChcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICBsaXN0ZW5lZFNvbmdzSW5CYXRjaDogU29uZ1tdLCBcbiAgICBleGNsdWRlU29uZ3M6IFNldDxzdHJpbmc+XG4gICk6IFByb21pc2U8U29uZ1tdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn6egIEZldGNoaW5nIHNtYXJ0IHBlcnNvbmFsaXplZCBzb25ncyBiYXNlZCBvbiBsaXN0ZW5pbmcgYmVoYXZpb3InKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn461IFNvbmdzIHVzZXIgYWN0dWFsbHkgbGlzdGVuZWQgdG86JywgbGlzdGVuZWRTb25nc0luQmF0Y2gubWFwKHMgPT4gcy5uYW1lKSk7XG4gICAgICBcbiAgICAgIGlmIChsaXN0ZW5lZFNvbmdzSW5CYXRjaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBObyBsaXN0ZW5lZCBzb25ncyBpbiBiYXRjaCwgZmFsbGluZyBiYWNrIHRvIHJlZ3VsYXIgcGVyc29uYWxpemF0aW9uJyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCB0YWdzIGFuZCBhcnRpc3RzIGZyb20gbGlzdGVuZWQgc29uZ3NcbiAgICAgIGNvbnN0IHByZWZlcnJlZFRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIGNvbnN0IHByZWZlcnJlZEFydGlzdHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIFxuICAgICAgbGlzdGVuZWRTb25nc0luQmF0Y2guZm9yRWFjaChzb25nID0+IHtcbiAgICAgICAgc29uZy50YWdzPy5mb3JFYWNoKHRhZyA9PiBwcmVmZXJyZWRUYWdzLmFkZCh0YWcudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICBwcmVmZXJyZWRBcnRpc3RzLmFkZChzb25nLmFydGlzdC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+Pt++4jyBQcmVmZXJyZWQgdGFnczonLCBBcnJheS5mcm9tKHByZWZlcnJlZFRhZ3MpKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn46kIFByZWZlcnJlZCBhcnRpc3RzOicsIEFycmF5LmZyb20ocHJlZmVycmVkQXJ0aXN0cykpO1xuXG4gICAgICAvLyBVc2UgY2FjaGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmV0Y2ggYW5kIGNhY2hlXG4gICAgICBsZXQgc29uZ3NEYXRhID0gc29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCFzb25nc0RhdGEpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnc29uZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJyonKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIHNvbmdzIGZvciBzbWFydCBwZXJzb25hbGl6YXRpb246JywgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBzb25ncyBmb3VuZCBpbiBkYXRhYmFzZScpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBzb25nc0RhdGEgPSBkYXRhO1xuICAgICAgICBzb25nc0NhY2hlLmN1cnJlbnQgPSBkYXRhO1xuICAgICAgfVxuXG4gICAgICBsZXQgdXNlckxpa2VkU29uZ3MgPSBsaWtlZFNvbmdzQ2FjaGUuY3VycmVudDtcbiAgICAgIGlmICghdXNlckxpa2VkU29uZ3MpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBsaWtlZERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpO1xuICAgICAgICB1c2VyTGlrZWRTb25ncyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICAgICAgICBpZiAobGlrZWREYXRhKSB7XG4gICAgICAgICAgbGlrZWREYXRhLmZvckVhY2goaXRlbSA9PiB1c2VyTGlrZWRTb25ncyEuYWRkKGl0ZW0uc29uZ19pZCkpO1xuICAgICAgICB9XG4gICAgICAgIGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50ID0gdXNlckxpa2VkU29uZ3M7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRlciBhbmQgc2NvcmUgc29uZ3MgYmFzZWQgb24gbGlzdGVuaW5nIHByZWZlcmVuY2VzIGFuZCBsYW5ndWFnZVxuICAgICAgLy8gVXNlIHRoZSBsYW5ndWFnZSBvZiB0aGUgZmlyc3QgbGlzdGVuZWQgc29uZyBhcyB0aGUgZmlsdGVyXG4gICAgICBjb25zdCBsYW5ndWFnZUZpbHRlciA9IGxpc3RlbmVkU29uZ3NJbkJhdGNoWzBdPy5sYW5ndWFnZTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVNvbmdzID0gc29uZ3NEYXRhLmZpbHRlcigoc29uZykgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICFleGNsdWRlU29uZ3MuaGFzKHNvbmcuZmlsZV9pZC50b1N0cmluZygpKSAmJlxuICAgICAgICAgIHNvbmcubGFuZ3VhZ2UgPT09IGxhbmd1YWdlRmlsdGVyXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYPCfjrUgQXZhaWxhYmxlIHNvbmdzIGZvciBzbWFydCByZWNvbW1lbmRhdGlvbnMgKGxhbmd1YWdlOiAke2xhbmd1YWdlRmlsdGVyfSk6ICR7YXZhaWxhYmxlU29uZ3MubGVuZ3RofWApO1xuXG4gICAgICBpZiAoYXZhaWxhYmxlU29uZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGF2YWlsYWJsZSBzb25ncyBhZnRlciBmaWx0ZXJpbmcnKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBTY29yZSBzb25ncyBiYXNlZCBvbiB1c2VyJ3MgbGlzdGVuaW5nIHByZWZlcmVuY2VzXG4gICAgICBjb25zdCBzY29yZWRTb25ncyA9IGF2YWlsYWJsZVNvbmdzLm1hcCgoc29uZykgPT4ge1xuICAgICAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgICAgIC8vIEhpZ2ggcHJpb3JpdHk6IFRhZyBtYXRjaGluZyB3aXRoIGxpc3RlbmVkIHNvbmdzXG4gICAgICAgIGNvbnN0IHNvbmdUYWdzID0gc29uZy50YWdzPy5tYXAoKHRhZzogc3RyaW5nKSA9PiB0YWcudG9Mb3dlckNhc2UoKSkgfHwgW107XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nVGFncyA9IHNvbmdUYWdzLmZpbHRlcigodGFnOiBzdHJpbmcpID0+IHByZWZlcnJlZFRhZ3MuaGFzKHRhZykpO1xuICAgICAgICBzY29yZSArPSBtYXRjaGluZ1RhZ3MubGVuZ3RoICogMjU7IC8vIEhpZ2hlciB3ZWlnaHQgZm9yIHRhZyBtYXRjaGluZ1xuXG4gICAgICAgIC8vIEhpZ2ggcHJpb3JpdHk6IEFydGlzdCBtYXRjaGluZyB3aXRoIGxpc3RlbmVkIHNvbmdzXG4gICAgICAgIGlmIChwcmVmZXJyZWRBcnRpc3RzLmhhcyhzb25nLmFydGlzdC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIHNjb3JlICs9IDMwOyAvLyBIaWdoZXIgd2VpZ2h0IGZvciBhcnRpc3QgbWF0Y2hpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1lZGl1bSBwcmlvcml0eTogU2FtZSBsYW5ndWFnZSBhcyBsaXN0ZW5lZCBzb25nc1xuICAgICAgICBjb25zdCBsaXN0ZW5lZExhbmd1YWdlcyA9IGxpc3RlbmVkU29uZ3NJbkJhdGNoLm1hcChzID0+IHMubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAobGlzdGVuZWRMYW5ndWFnZXMuaW5jbHVkZXMoc29uZy5sYW5ndWFnZSkpIHtcbiAgICAgICAgICBzY29yZSArPSAxNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvd2VyIHByaW9yaXR5OiBHZW5lcmFsIHBvcHVsYXJpdHlcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5sb2coMSArIChzb25nLmxpa2VzIHx8IDApKSAqIDI7XG4gICAgICAgIHNjb3JlICs9IE1hdGgubG9nKDEgKyAoc29uZy52aWV3cyB8fCAwKSkgKiAxO1xuXG4gICAgICAgIC8vIEJvbnVzIGZvciBsaWtlZCBzb25nc1xuICAgICAgICBpZiAodXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpIHtcbiAgICAgICAgICBzY29yZSArPSAxMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBzbWFsbCByYW5kb21uZXNzIHRvIGF2b2lkIHJlcGV0aXRpb25cbiAgICAgICAgc2NvcmUgKz0gTWF0aC5yYW5kb20oKSAqIDI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb25nOiBjb252ZXJ0RGF0YWJhc2VTb25nKHNvbmcsIHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKSwgXG4gICAgICAgICAgc2NvcmVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTb3J0IGJ5IHNjb3JlIGFuZCByZXR1cm4gdG9wIHJlY29tbWVuZGF0aW9uc1xuICAgICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gc2NvcmVkU29uZ3NcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgICAuc2xpY2UoMCwgMTUpIC8vIEdldCBtb3JlIHNvbmdzIGZvciB2YXJpZXR5XG4gICAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkuc29uZyk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn6egIFNtYXJ0IHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiBsaXN0ZW5pbmcgYmVoYXZpb3I6JywgXG4gICAgICAgIHJlY29tbWVuZGF0aW9ucy5zbGljZSgwLCA1KS5tYXAocyA9PiBgJHtzLm5hbWV9IGJ5ICR7cy5hcnRpc3R9YCkpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBnZXRTbWFydFBlcnNvbmFsaXplZFNvbmdzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29udmVydCBkYXRhYmFzZSBzb25nIHRvIFVJIHNvbmcgZm9ybWF0XG4gIGNvbnN0IGNvbnZlcnREYXRhYmFzZVNvbmcgPSAoZGJTb25nOiBEYXRhYmFzZVNvbmcsIGlzTGlrZWQ6IGJvb2xlYW4gPSBmYWxzZSk6IFNvbmcgPT4gKHtcbiAgICBmaWxlX2lkOiBkYlNvbmcuZmlsZV9pZCxcbiAgICBpbWdfaWQ6IGRiU29uZy5pbWdfaWQsXG4gICAgbmFtZTogZGJTb25nLm5hbWUsXG4gICAgYXJ0aXN0OiBkYlNvbmcuYXJ0aXN0LFxuICAgIGxhbmd1YWdlOiBkYlNvbmcubGFuZ3VhZ2UsXG4gICAgdGFnczogZGJTb25nLnRhZ3MsXG4gICAgdmlld3M6IGRiU29uZy52aWV3cyxcbiAgICBsaWtlczogZGJTb25nLmxpa2VzLFxuICAgIGlkOiBkYlNvbmcuZmlsZV9pZC50b1N0cmluZygpLFxuICAgIGltYWdlOiBgaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvJHtkYlNvbmcuaW1nX2lkfS9wZXhlbHMtcGhvdG8tJHtkYlNvbmcuaW1nX2lkfS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDBgLFxuICAgIGlzTGlrZWRcbiAgfSlcblxuICAvLyBGZXRjaCBhbGwgc29uZ3NcbiAgY29uc3QgZmV0Y2hTb25ncyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGNvbnNvbGUubG9nKCfwn5SNIGZldGNoU29uZ3MgY2FsbGVkIHdpdGggdXNlcklkOicsIHVzZXJJZClcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBObyB1c2VySWQgZm91bmQsIGNsZWFyaW5nIHNvbmdzIGRhdGEnKVxuICAgICAgc2V0U29uZ3MoW10pXG4gICAgICBzZXRQZXJzb25hbGl6ZWRTb25ncyhbXSlcbiAgICAgIHNldFRyZW5kaW5nU29uZ3MoW10pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSlcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhbGwgc29uZ3MgZnJvbSBzdXBhYmFzZS4uLicpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IGNvbm5lY3Rpb24gZmlyc3RcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SXIFRlc3RpbmcgU3VwYWJhc2UgY29ubmVjdGlvbi4uLicpO1xuICAgICAgY29uc3QgeyBkYXRhOiB0ZXN0RGF0YSwgZXJyb3I6IHRlc3RFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnY291bnQnKVxuICAgICAgICAubGltaXQoMSlcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmICh0ZXN0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFN1cGFiYXNlIGNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgdGVzdEVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZDogJHt0ZXN0RXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBTdXBhYmFzZSBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgIFxuICAgICAgLy8gRmV0Y2ggc29uZ3Mgd2l0aCBzaW1wbGVyIHF1ZXJ5IGZpcnN0XG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBGZXRjaGluZyBzb25ncyBkYXRhLi4uJyk7XG4gICAgICBjb25zdCB7IGRhdGE6IHNvbmdzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAubGltaXQoMTAwKSAvLyBTdGFydCB3aXRoIGEgc21hbGxlciBsaW1pdFxuICAgICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIFxuICAgICAgaWYgKCFzb25nc0RhdGEgfHwgc29uZ3NEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBzb25ncyBmb3VuZCBpbiBkYXRhYmFzZScpO1xuICAgICAgICBzZXRTb25ncyhbXSk7XG4gICAgICAgIHNldFBlcnNvbmFsaXplZFNvbmdzKFtdKTtcbiAgICAgICAgc2V0VHJlbmRpbmdTb25ncyhbXSk7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRmV0Y2hlZCBzb25nczonLCBzb25nc0RhdGEubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgLy8gQ2FjaGUgdGhlIHNvbmdzIGRhdGFcbiAgICAgIHNvbmdzQ2FjaGUuY3VycmVudCA9IHNvbmdzRGF0YTtcblxuICAgICAgLy8gRmV0Y2ggbGlrZWQgc29uZ3NcbiAgICAgIGNvbnNvbGUubG9nKCfinaTvuI8gRmV0Y2hpbmcgbGlrZWQgc29uZ3MuLi4nKTtcbiAgICAgIGxldCB1c2VyTGlrZWRTb25ncyA9IG5ldyBTZXQ8bnVtYmVyPigpXG4gICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0KGxpa2VkRGF0YS5tYXAoaXRlbSA9PiBpdGVtLnNvbmdfaWQpKVxuICAgICAgICBzZXRMaWtlZFNvbmdzKHVzZXJMaWtlZFNvbmdzKVxuICAgICAgICAvLyBDYWNoZSBsaWtlZCBzb25nc1xuICAgICAgICBsaWtlZFNvbmdzQ2FjaGUuY3VycmVudCA9IHVzZXJMaWtlZFNvbmdzO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ+KchSBGZXRjaGVkIGxpa2VkIHNvbmdzOicsIHVzZXJMaWtlZFNvbmdzLnNpemUpO1xuXG4gICAgICAvLyBGZXRjaCB1c2VyIGhpc3RvcnkgKGZvciBtaW51dGVzX2xpc3RlbmVkKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ggRmV0Y2hpbmcgdXNlciBoaXN0b3J5Li4uJyk7XG4gICAgICBjb25zdCB7IGRhdGE6IGhpc3RvcnlEYXRhLCBlcnJvcjogaGlzdG9yeUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnaGlzdG9yeScpXG4gICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQsIG1pbnV0ZXNfbGlzdGVuZWQsIHNvbmdzKCopJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAub3JkZXIoJ21pbnV0ZXNfbGlzdGVuZWQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgLmxpbWl0KDUwKSAvLyBMaW1pdCBoaXN0b3J5IHRvIHByZXZlbnQgbGFyZ2UgcXVlcmllc1xuICAgICAgaWYgKGhpc3RvcnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBFcnJvciBmZXRjaGluZyBoaXN0b3J5OicsIGhpc3RvcnlFcnJvcik7XG4gICAgICAgIC8vIERvbid0IHRocm93LCBjb250aW51ZSB3aXRob3V0IGhpc3RvcnlcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRmV0Y2hlZCB1c2VyIGhpc3Rvcnk6JywgaGlzdG9yeURhdGE/Lmxlbmd0aCB8fCAwKTtcblxuICAgICAgLy8gR2V0IHRvcCAxNSBtb3N0IGxpc3RlbmVkIHNvbmdzIGZyb20gaGlzdG9yeVxuICAgICAgY29uc3QgdG9wSGlzdG9yeSA9IChoaXN0b3J5RGF0YSB8fCBbXSkuc2xpY2UoMCwgMTUpLmZpbHRlcihoID0+IGguc29uZ3MpXG4gICAgICAvLyBDb2xsZWN0IHRhZ3MgYW5kIGFydGlzdHMgZnJvbSB0b3AgMTVcbiAgICAgIGNvbnN0IHRhZ0NvdW50OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge31cbiAgICAgIGNvbnN0IGFydGlzdENvdW50OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge31cbiAgICAgIHRvcEhpc3RvcnkuZm9yRWFjaChoID0+IHtcbiAgICAgICAgLy8gaC5zb25ncyBtYXkgYmUgYW4gYXJyYXkgb3Igb2JqZWN0LCB1c2UgZmlyc3QgaWYgYXJyYXlcbiAgICAgICAgY29uc3Qgc29uZ09iaiA9IEFycmF5LmlzQXJyYXkoaC5zb25ncykgPyBoLnNvbmdzWzBdIDogaC5zb25ncztcbiAgICAgICAgKHNvbmdPYmo/LnRhZ3MgfHwgW10pLmZvckVhY2goKHRhZzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHRhZ0NvdW50W3RdID0gKHRhZ0NvdW50W3RdIHx8IDApICsgMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzb25nT2JqPy5hcnRpc3QpIHtcbiAgICAgICAgICBjb25zdCBhID0gc29uZ09iai5hcnRpc3QudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBhcnRpc3RDb3VudFthXSA9IChhcnRpc3RDb3VudFthXSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gRmluZCBtb3N0IGNvbW1vbiB0YWdzIGFuZCBhcnRpc3RzXG4gICAgICBjb25zdCBjb21tb25UYWdzID0gT2JqZWN0LmVudHJpZXModGFnQ291bnQpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlcbiAgICAgICAgLnNsaWNlKDAsIDUpXG4gICAgICAgIC5tYXAoKFt0YWddKSA9PiB0YWcpO1xuICAgICAgY29uc3QgY29tbW9uQXJ0aXN0cyA9IE9iamVjdC5lbnRyaWVzKGFydGlzdENvdW50KVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pXG4gICAgICAgIC5zbGljZSgwLCA1KVxuICAgICAgICAubWFwKChbYXJ0aXN0XSkgPT4gYXJ0aXN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBzaW1pbGFyIHRhZ3M6JywgY29tbW9uVGFncyk7XG4gICAgICBjb25zb2xlLmxvZygnRm91bmQgc2ltaWxhciBhcnRpc3RzOicsIGNvbW1vbkFydGlzdHMpO1xuXG4gICAgICAvLyBTb25ncyBpbiBoaXN0b3J5ICh0byBleGNsdWRlIGZvciBzbWFydCBzb3J0KVxuICAgICAgY29uc3QgaGlzdG9yeVNvbmdJZHMgPSBuZXcgU2V0KChoaXN0b3J5RGF0YSB8fCBbXSkubWFwKGggPT4gaC5zb25nX2lkPy50b1N0cmluZygpKSk7XG5cbiAgICAgIC8vIENvbnZlcnQgYWxsIHNvbmdzXG4gICAgICBjb25zdCBjb252ZXJ0ZWRTb25ncyA9IHNvbmdzRGF0YS5tYXAoc29uZyA9PlxuICAgICAgICBjb252ZXJ0RGF0YWJhc2VTb25nKHNvbmcsIHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBDb252ZXJ0ZWQgc29uZ3M6JywgY29udmVydGVkU29uZ3MubGVuZ3RoKTtcblxuICAgICAgc2V0U29uZ3MoY29udmVydGVkU29uZ3MpOyAvLyBzb25ncyBpcyBub3cgYWxsIHNvbmdzLCBub3QgcGVyc29uYWxpemVkXG5cbiAgICAgIC8vIEZpbHRlciBvdXQgc29uZ3MgaW4gaGlzdG9yeSBmb3IgcGVyc29uYWxpemVkIHNvcnRcbiAgICAgIGNvbnN0IGZpbHRlcmVkU29uZ3MgPSBjb252ZXJ0ZWRTb25ncy5maWx0ZXIoc29uZyA9PiAhaGlzdG9yeVNvbmdJZHMuaGFzKHNvbmcuaWQpKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRmlsdGVyZWQgc29uZ3MgZm9yIHBlcnNvbmFsaXphdGlvbjonLCBmaWx0ZXJlZFNvbmdzLmxlbmd0aCk7XG5cbiAgICAgIC8vIFNjb3JlIHNvbmdzIGJ5IHRhZy9hcnRpc3QgbWF0Y2hcbiAgICAgIGNvbnN0IHNjb3JlZFNvbmdzID0gZmlsdGVyZWRTb25ncy5tYXAoc29uZyA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG4gICAgICAgIC8vIFRhZyBtYXRjaFxuICAgICAgICBjb25zdCBzb25nVGFncyA9IChzb25nLnRhZ3MgfHwgW10pLm1hcCgodDogc3RyaW5nKSA9PiB0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzY29yZSArPSBzb25nVGFncy5maWx0ZXIodCA9PiBjb21tb25UYWdzLmluY2x1ZGVzKHQpKS5sZW5ndGggKiAxMDtcbiAgICAgICAgLy8gQXJ0aXN0IG1hdGNoXG4gICAgICAgIGlmIChzb25nLmFydGlzdCAmJiBjb21tb25BcnRpc3RzLmluY2x1ZGVzKHNvbmcuYXJ0aXN0LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gMjA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhcml0eVxuICAgICAgICBzY29yZSArPSAoc29uZy52aWV3cyB8fCAwKSArIChzb25nLmxpa2VzIHx8IDApO1xuICAgICAgICByZXR1cm4geyBzb25nLCBzY29yZSB9O1xuICAgICAgfSk7XG4gICAgICAvLyBTb3J0IGJ5IHNjb3JlIGRlc2NlbmRpbmdcbiAgICAgIGNvbnN0IHBlcnNvbmFsaXplZFNvcnRlZCA9IHNjb3JlZFNvbmdzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKS5tYXAocyA9PiBzLnNvbmcpO1xuXG4gICAgICBzZXRQZXJzb25hbGl6ZWRTb25ncyhwZXJzb25hbGl6ZWRTb3J0ZWQpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBTZXQgcGVyc29uYWxpemVkIHNvbmdzOicsIHBlcnNvbmFsaXplZFNvcnRlZC5sZW5ndGgpO1xuXG4gICAgICAvLyBUcmVuZGluZzogdG9wIDE1IGJ5IHZpZXdzK2xpa2VzIChmcm9tIGFsbCBzb25ncywgaW5jbHVkaW5nIGhpc3RvcnkpXG4gICAgICBjb25zdCB0cmVuZGluZyA9IFsuLi5jb252ZXJ0ZWRTb25nc11cbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IChiLnZpZXdzICsgYi5saWtlcykgLSAoYS52aWV3cyArIGEubGlrZXMpKVxuICAgICAgICAuc2xpY2UoMCwgMTUpO1xuICAgICAgc2V0VHJlbmRpbmdTb25ncyh0cmVuZGluZyk7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFNldCB0cmVuZGluZyBzb25nczonLCB0cmVuZGluZy5sZW5ndGgpO1xuXG4gICAgICAvLyBTZXQgbGFzdCBwbGF5ZWQgc29uZyBhcyBiZWZvcmVcbiAgICAgIGNvbnNvbGUubG9nKCfwn461IFNldHRpbmcgbGFzdCBwbGF5ZWQgc29uZy4uLicpO1xuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnNlbGVjdCgnbGFzdF9zb25nX2ZpbGVfaWQnKVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBpZiAodXNlckRhdGE/Lmxhc3Rfc29uZ19maWxlX2lkKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTb25nID0gY29udmVydGVkU29uZ3MuZmluZChzb25nID0+IHNvbmcuZmlsZV9pZCA9PT0gdXNlckRhdGEubGFzdF9zb25nX2ZpbGVfaWQpXG4gICAgICAgIGlmIChsYXN0U29uZykge1xuICAgICAgICAgIHNldExhc3RQbGF5ZWRTb25nKGxhc3RTb25nKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU2V0IGxhc3QgcGxheWVkIHNvbmc6JywgbGFzdFNvbmcubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CfjokgU3VjY2Vzc2Z1bGx5IGxvYWRlZCBhbGwgZGF0YSEnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIHNvbmdzOicsIGVycm9yKVxuICAgICAgXG4gICAgICAvLyBTaG93IHVzZXItZnJpZW5kbHkgZXJyb3IgbWVzc2FnZVxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdjb25uZWN0aW9uJykgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3RpbWVvdXQnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfwn4yQIENvbm5lY3Rpb24gaXNzdWUgZGV0ZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnYXV0aCcpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ/CflJAgQXV0aGVudGljYXRpb24gaXNzdWUgZGV0ZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0U29uZ3MoW10pXG4gICAgICBzZXRQZXJzb25hbGl6ZWRTb25ncyhbXSlcbiAgICAgIHNldFRyZW5kaW5nU29uZ3MoW10pXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHBlcnNvbmFsaXplZCBzb25ncyB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZyBhbmQgZmlsdGVyaW5nXG4gIGNvbnN0IGdldFBlcnNvbmFsaXplZFNvbmdzID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBjdXJyZW50U29uZzogU29uZywgbGlzdGVuZWRTb25ncz86IFNldDxzdHJpbmc+KTogUHJvbWlzZTxTb25nW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CfjrUgRmV0Y2hpbmcgcGVyc29uYWxpemVkIHNvbmdzIGZvcjonLCBjdXJyZW50U29uZy5uYW1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn461IExpc3RlbmVkIHNvbmdzIGNvdW50OicsIGxpc3RlbmVkU29uZ3M/LnNpemUgfHwgMCk7XG4gICAgICBcbiAgICAgIC8vIDEuIEZldGNoIGFsbCBzb25ncyBmcm9tIGNhY2hlIG9yIGNsb3VkXG4gICAgICBsZXQgc29uZ3NEYXRhID0gc29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCFzb25nc0RhdGEpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnc29uZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJyonKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIHNvbmdzIGZvciBwZXJzb25hbGl6YXRpb246JywgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBzb25ncyBmb3VuZCBpbiBkYXRhYmFzZScpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBzb25nc0RhdGEgPSBkYXRhO1xuICAgICAgICBzb25nc0NhY2hlLmN1cnJlbnQgPSBkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBGZXRjaCB1c2VyJ3MgbGlzdGVuaW5nIGhpc3RvcnkgKG5vdCBjYWNoZWQsIGFzIGl0IG1heSBjaGFuZ2UgZnJlcXVlbnRseSlcbiAgICAgIGNvbnN0IHsgZGF0YTogaGlzdG9yeURhdGEsIGVycm9yOiBoaXN0b3J5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdoaXN0b3J5JylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCwgbWludXRlc19saXN0ZW5lZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICBpZiAoaGlzdG9yeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBoaXN0b3J5OicsIGhpc3RvcnlFcnJvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBoaXN0b3J5TWFwID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKTtcbiAgICAgIGlmIChoaXN0b3J5RGF0YSkge1xuICAgICAgICBoaXN0b3J5RGF0YS5mb3JFYWNoKGggPT4gaGlzdG9yeU1hcC5zZXQoaC5zb25nX2lkLCBoLm1pbnV0ZXNfbGlzdGVuZWQgfHwgMCkpO1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBHZXQgdXNlcidzIGxpa2VkIHNvbmdzIGZyb20gY2FjaGUgb3IgY2xvdWRcbiAgICAgIGxldCB1c2VyTGlrZWRTb25ncyA9IGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCF1c2VyTGlrZWRTb25ncykge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQnKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICAgIHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgICBsaWtlZERhdGEuZm9yRWFjaChpdGVtID0+IHVzZXJMaWtlZFNvbmdzIS5hZGQoaXRlbS5zb25nX2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSB1c2VyTGlrZWRTb25ncztcbiAgICAgIH1cblxuICAgICAgLy8gNC4gRmlsdGVyIGFuZCBzY29yZSBzb25ncyAoYWRkIGxhbmd1YWdlIGZpbHRlcilcbiAgICAgIGNvbnN0IGxhbmd1YWdlRmlsdGVyID0gY3VycmVudFNvbmcubGFuZ3VhZ2U7XG4gICAgICBjb25zdCBhdmFpbGFibGVTb25ncyA9IHNvbmdzRGF0YS5maWx0ZXIoKHNvbmcpID0+IHtcbiAgICAgICAgLy8gRXhjbHVkZSBjdXJyZW50IHNvbmdcbiAgICAgICAgaWYgKHNvbmcuZmlsZV9pZCA9PT0gY3VycmVudFNvbmcuZmlsZV9pZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGNsdWRlIGxpc3RlbmVkIHNvbmdzIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmIChsaXN0ZW5lZFNvbmdzICYmIGxpc3RlbmVkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZC50b1N0cmluZygpKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEV4Y2x1ZGluZyBsaXN0ZW5lZCBzb25nOiAke3NvbmcubmFtZX0gYnkgJHtzb25nLmFydGlzdH1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBpbmNsdWRlIHNvbmdzIHdpdGggdGhlIHNhbWUgbGFuZ3VhZ2UgYXMgY3VycmVudCBzb25nXG4gICAgICAgIGlmIChzb25nLmxhbmd1YWdlICE9PSBsYW5ndWFnZUZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+OtSBBdmFpbGFibGUgc29uZ3MgYWZ0ZXIgZmlsdGVyaW5nIChsYW5ndWFnZTogJHtsYW5ndWFnZUZpbHRlcn0pOiAke2F2YWlsYWJsZVNvbmdzLmxlbmd0aH1gKTtcblxuICAgICAgaWYgKGF2YWlsYWJsZVNvbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBhdmFpbGFibGUgc29uZ3MgYWZ0ZXIgZmlsdGVyaW5nJyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gNS4gU2NvcmUgYW5kIHNvcnQgc29uZ3NcbiAgICAgIGNvbnN0IHNjb3JlZFNvbmdzID0gYXZhaWxhYmxlU29uZ3MubWFwKChzb25nKSA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAgICAgLy8gVGFnIG1hdGNoaW5nIChoaWdoZXN0IHByaW9yaXR5KVxuICAgICAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBzb25nLnRhZ3M/LmZpbHRlcigodGFnOiBzdHJpbmcpID0+XG4gICAgICAgICAgY3VycmVudFNvbmcudGFncz8uaW5jbHVkZXModGFnKVxuICAgICAgICApIHx8IFtdO1xuICAgICAgICBzY29yZSArPSBtYXRjaGluZ1RhZ3MubGVuZ3RoICogMTU7XG5cbiAgICAgICAgLy8gQXJ0aXN0IG1hdGNoaW5nXG4gICAgICAgIGlmIChzb25nLmFydGlzdCA9PT0gY3VycmVudFNvbmcuYXJ0aXN0KSB7XG4gICAgICAgICAgc2NvcmUgKz0gMjU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYW5ndWFnZSBtYXRjaGluZ1xuICAgICAgICBpZiAoc29uZy5sYW5ndWFnZSA9PT0gY3VycmVudFNvbmcubGFuZ3VhZ2UpIHtcbiAgICAgICAgICBzY29yZSArPSAxMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpc3RlbmluZyBoaXN0b3J5IGJvb3N0XG4gICAgICAgIGNvbnN0IGxpc3RlbmVkTWludXRlcyA9IGhpc3RvcnlNYXAuZ2V0KHNvbmcuZmlsZV9pZCkgfHwgMDtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5taW4obGlzdGVuZWRNaW51dGVzICogMiwgMjApOyAvLyBDYXAgYXQgMjAgcG9pbnRzXG5cbiAgICAgICAgLy8gUG9wdWxhcml0eSBib29zdCAobGlrZXMgYW5kIHZpZXdzKVxuICAgICAgICBzY29yZSArPSBNYXRoLmxvZygxICsgKHNvbmcubGlrZXMgfHwgMCkpICogMjtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5sb2coMSArIChzb25nLnZpZXdzIHx8IDApKSAqIDE7XG5cbiAgICAgICAgLy8gTGlrZWQgc29uZ3MgYm9vc3RcbiAgICAgICAgaWYgKHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjb250cm9sbGVkIHJhbmRvbW5lc3MgdG8gYXZvaWQgcmVwZXRpdGlvblxuICAgICAgICBzY29yZSArPSBNYXRoLnJhbmRvbSgpICogMztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvbmc6IGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZywgdXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpLFxuICAgICAgICAgIHNjb3JlXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gNi4gU29ydCBieSBzY29yZSBhbmQgcmV0dXJuIHRvcCByZWNvbW1lbmRhdGlvbnNcbiAgICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IHNjb3JlZFNvbmdzXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSlcbiAgICAgICAgLnNsaWNlKDAsIDEwKSAvLyBHZXQgbW9yZSBzb25ncyB0byBoYXZlIGEgYnVmZmVyXG4gICAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkuc29uZyk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn461IFBlcnNvbmFsaXplZCByZWNvbW1lbmRhdGlvbnM6JywgcmVjb21tZW5kYXRpb25zLnNsaWNlKDAsIDUpLm1hcChzID0+IGAke3MubmFtZX0gYnkgJHtzLmFydGlzdH1gKSk7XG4gICAgICBjb25zb2xlLmxvZygn8J+OtSBUb3RhbCBhdmFpbGFibGUgc29uZ3M6JywgYXZhaWxhYmxlU29uZ3MubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW4gZ2V0UGVyc29uYWxpemVkU29uZ3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICAvLyBGZXRjaCByZWNlbnRseSBwbGF5ZWQgc29uZ3MgYmFzZWQgb24gbGlzdGVuaW5nIGhpc3RvcnlcbiAgY29uc3QgZmV0Y2hSZWNlbnRseVBsYXllZCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBzZXRSZWNlbnRseVBsYXllZFNvbmdzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEZldGNoaW5nIHJlY2VudGx5IHBsYXllZCBzb25ncy4uLicpO1xuICAgICAgLy8gR2V0IHVzZXIncyBsaXN0ZW5pbmcgaGlzdG9yeSBzb3J0ZWQgYnkgbWludXRlcyBsaXN0ZW5lZFxuICAgICAgY29uc3QgeyBkYXRhOiBoaXN0b3J5RGF0YSwgZXJyb3I6IGhpc3RvcnlFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2hpc3RvcnknKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICBzb25nX2lkLFxuICAgICAgICAgIG1pbnV0ZXNfbGlzdGVuZWQsXG4gICAgICAgICAgc29uZ3MgKCopXG4gICAgICAgIGApXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLm9yZGVyKCdtaW51dGVzX2xpc3RlbmVkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgIC5saW1pdCgxNSkgLy8gSW5jcmVhc2UgbGltaXQgc2xpZ2h0bHlcblxuICAgICAgaWYgKGhpc3RvcnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBFcnJvciBmZXRjaGluZyByZWNlbnRseSBwbGF5ZWQ6JywgaGlzdG9yeUVycm9yKVxuICAgICAgICBzZXRSZWNlbnRseVBsYXllZFNvbmdzKFtdKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFoaXN0b3J5RGF0YSB8fCBoaXN0b3J5RGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KEue+4jyBObyByZWNlbnRseSBwbGF5ZWQgc29uZ3MgZm91bmQnKTtcbiAgICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB1c2VyJ3MgbGlrZWQgc29uZ3MgZm9yIHByb3BlciBjb252ZXJzaW9uXG4gICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIFxuICAgICAgY29uc3QgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0PG51bWJlcj4oKVxuICAgICAgaWYgKGxpa2VkRGF0YSkge1xuICAgICAgICBsaWtlZERhdGEuZm9yRWFjaChpdGVtID0+IHVzZXJMaWtlZFNvbmdzLmFkZChpdGVtLnNvbmdfaWQpKVxuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IHRvIFNvbmcgZm9ybWF0XG4gICAgICBjb25zdCByZWNlbnRTb25ncyA9IGhpc3RvcnlEYXRhXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnNvbmdzKSAvLyBFbnN1cmUgc29uZyBkYXRhIGV4aXN0c1xuICAgICAgICAubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IHNvbmdPYmogPSBBcnJheS5pc0FycmF5KGl0ZW0uc29uZ3MpID8gaXRlbS5zb25nc1swXSA6IGl0ZW0uc29uZ3M7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZ09iaiwgdXNlckxpa2VkU29uZ3MuaGFzKGl0ZW0uc29uZ19pZCkpO1xuICAgICAgICB9KTtcblxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhyZWNlbnRTb25ncylcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU2V0IHJlY2VudGx5IHBsYXllZCBzb25nczonLCByZWNlbnRTb25ncy5sZW5ndGgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgcmVjZW50bHkgcGxheWVkIHNvbmdzOicsIGVycm9yKVxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICB9XG4gIH1cblxuICAvLyBGZXRjaCB1c2VyIHBsYXlsaXN0c1xuICBjb25zdCBmZXRjaFBsYXlsaXN0cyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gRmV0Y2hpbmcgcGxheWxpc3RzLi4uJyk7XG4gICAgICBjb25zdCB7IGRhdGE6IHBsYXlsaXN0c0RhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwbGF5bGlzdF9zb25ncyAoXG4gICAgICAgICAgICBzb25ncyAoKilcbiAgICAgICAgICApXG4gICAgICAgIGApXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLmxpbWl0KDIwKSAvLyBMaW1pdCBwbGF5bGlzdHMgdG8gcHJldmVudCBsYXJnZSBxdWVyaWVzXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBFcnJvciBmZXRjaGluZyBwbGF5bGlzdHM6JywgZXJyb3IpO1xuICAgICAgICBzZXRQbGF5bGlzdHMoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghcGxheWxpc3RzRGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIE5vIHBsYXlsaXN0cyBmb3VuZCcpO1xuICAgICAgICBzZXRQbGF5bGlzdHMoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnZlcnRlZFBsYXlsaXN0czogUGxheWxpc3RbXSA9IHBsYXlsaXN0c0RhdGE/Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgIGNvbnN0IHBsYXlsaXN0U29uZ3MgPSBwbGF5bGlzdC5wbGF5bGlzdF9zb25ncz8ubWFwKChwczogYW55KSA9PiBcbiAgICAgICAgICBjb252ZXJ0RGF0YWJhc2VTb25nKHBzLnNvbmdzLCBsaWtlZFNvbmdzLmhhcyhwcy5zb25ncy5maWxlX2lkKSlcbiAgICAgICAgKSB8fCBbXVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHBsYXlsaXN0LmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgbmFtZTogcGxheWxpc3QubmFtZSxcbiAgICAgICAgICBzb25nQ291bnQ6IHBsYXlsaXN0U29uZ3MubGVuZ3RoLFxuICAgICAgICAgIGltYWdlOiBwbGF5bGlzdFNvbmdzWzBdPy5pbWFnZSB8fCAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnLFxuICAgICAgICAgIHNvbmdzOiBwbGF5bGlzdFNvbmdzXG4gICAgICAgIH1cbiAgICAgIH0pIHx8IFtdXG5cbiAgICAgIHNldFBsYXlsaXN0cyhjb252ZXJ0ZWRQbGF5bGlzdHMpXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFNldCBwbGF5bGlzdHM6JywgY29udmVydGVkUGxheWxpc3RzLmxlbmd0aCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBwbGF5bGlzdHM6JywgZXJyb3IpXG4gICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgfVxuICB9XG5cbiAgLy8gVG9nZ2xlIGxpa2Ugc29uZ1xuICBjb25zdCB0b2dnbGVMaWtlID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc29uZ0ZpbGVJZCA9IHBhcnNlSW50KHNvbmdJZCk7XG4gICAgY29uc3QgaXNDdXJyZW50bHlMaWtlZCA9IGxpa2VkU29uZ3MuaGFzKHNvbmdGaWxlSWQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc0N1cnJlbnRseUxpa2VkKSB7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIGxpa2VkX3NvbmdzXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgICAgLmVxKCdzb25nX2lkJywgc29uZ0ZpbGVJZCk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgICAgICAvLyBEZWNyZW1lbnQgbGlrZXNcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UucnBjKCdkZWNyZW1lbnRfc29uZ19saWtlcycsIHsgc29uZ19maWxlX2lkOiBzb25nRmlsZUlkIH0pO1xuXG4gICAgICAgIHNldExpa2VkU29uZ3MocHJldiA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3U2V0ID0gbmV3IFNldChwcmV2KTtcbiAgICAgICAgICBuZXdTZXQuZGVsZXRlKHNvbmdGaWxlSWQpO1xuICAgICAgICAgIHJldHVybiBuZXdTZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIHRvIGxpa2VkX3NvbmdzXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIHNvbmdfaWQ6IHNvbmdGaWxlSWQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgICAgICAvLyBJbmNyZW1lbnQgbGlrZXNcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UucnBjKCdpbmNyZW1lbnRfc29uZ19saWtlcycsIHsgc29uZ19maWxlX2lkOiBzb25nRmlsZUlkIH0pO1xuXG4gICAgICAgIHNldExpa2VkU29uZ3MocHJldiA9PiBuZXcgU2V0KHByZXYpLmFkZChzb25nRmlsZUlkKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBzb25ncyBzdGF0ZVxuICAgICAgc2V0U29uZ3MocHJldlNvbmdzID0+XG4gICAgICAgIHByZXZTb25ncy5tYXAoc29uZyA9PlxuICAgICAgICAgIHNvbmcuaWQgPT09IHNvbmdJZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLi4uc29uZyxcbiAgICAgICAgICAgICAgICBpc0xpa2VkOiAhaXNDdXJyZW50bHlMaWtlZCxcbiAgICAgICAgICAgICAgICBsaWtlczogc29uZy5saWtlcyArIChpc0N1cnJlbnRseUxpa2VkID8gLTEgOiAxKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBzb25nXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIC8vIFVwZGF0ZSBwbGF5bGlzdHMgc3RhdGVcbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2UGxheWxpc3RzID0+XG4gICAgICAgIHByZXZQbGF5bGlzdHMubWFwKHBsYXlsaXN0ID0+ICh7XG4gICAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgICAgc29uZ3M6IHBsYXlsaXN0LnNvbmdzLm1hcChzb25nID0+XG4gICAgICAgICAgICBzb25nLmlkID09PSBzb25nSWRcbiAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAuLi5zb25nLFxuICAgICAgICAgICAgICAgICAgaXNMaWtlZDogIWlzQ3VycmVudGx5TGlrZWQsXG4gICAgICAgICAgICAgICAgICBsaWtlczogc29uZy5saWtlcyArIChpc0N1cnJlbnRseUxpa2VkID8gLTEgOiAxKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogc29uZ1xuICAgICAgICAgICksXG4gICAgICAgIH0pKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdG9nZ2xpbmcgbGlrZTonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIENyZWF0ZSBwbGF5bGlzdFxuICBjb25zdCBjcmVhdGVQbGF5bGlzdCA9IGFzeW5jIChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIGNvbnN0IG5ld1BsYXlsaXN0OiBQbGF5bGlzdCA9IHtcbiAgICAgICAgaWQ6IGRhdGEuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICBzb25nQ291bnQ6IDAsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnLFxuICAgICAgICBzb25nczogW11cbiAgICAgIH1cblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gWy4uLnByZXYsIG5ld1BsYXlsaXN0XSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIHBsYXlsaXN0XG4gIGNvbnN0IGRlbGV0ZVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKCF1c2VySWQpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gcHJldi5maWx0ZXIocGxheWxpc3QgPT4gcGxheWxpc3QuaWQgIT09IHBsYXlsaXN0SWQpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBSZW5hbWUgcGxheWxpc3RcbiAgY29uc3QgcmVuYW1lUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLnVwZGF0ZSh7IG5hbWU6IG5ld05hbWUgfSlcbiAgICAgICAgLmVxKCdpZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKHBsYXlsaXN0ID0+IFxuICAgICAgICAgIHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkIFxuICAgICAgICAgICAgPyB7IC4uLnBsYXlsaXN0LCBuYW1lOiBuZXdOYW1lIH1cbiAgICAgICAgICAgIDogcGxheWxpc3RcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5hbWluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgc29uZyB0byBwbGF5bGlzdFxuICBjb25zdCBhZGRTb25nVG9QbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIHNvbmc6IFNvbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3Rfc29uZ3MnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBwbGF5bGlzdF9pZDogcGFyc2VJbnQocGxheWxpc3RJZCksXG4gICAgICAgICAgc29uZ19pZDogc29uZy5maWxlX2lkXG4gICAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKHBsYXlsaXN0ID0+IHtcbiAgICAgICAgICBpZiAocGxheWxpc3QuaWQgPT09IHBsYXlsaXN0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvbmdFeGlzdHMgPSBwbGF5bGlzdC5zb25ncy5zb21lKHMgPT4gcy5pZCA9PT0gc29uZy5pZClcbiAgICAgICAgICAgIGlmICghc29uZ0V4aXN0cykge1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkU29uZ3MgPSBbLi4ucGxheWxpc3Quc29uZ3MsIHNvbmddXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgICAgICAgICAgc29uZ3M6IHVwZGF0ZWRTb25ncyxcbiAgICAgICAgICAgICAgICBzb25nQ291bnQ6IHVwZGF0ZWRTb25ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHVwZGF0ZWRTb25nc1swXT8uaW1hZ2UgfHwgcGxheWxpc3QuaW1hZ2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxheWxpc3RcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHNvbmcgdG8gcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHNvbmcgZnJvbSBwbGF5bGlzdFxuICBjb25zdCByZW1vdmVTb25nRnJvbVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3Rfc29uZ3MnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdwbGF5bGlzdF9pZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3NvbmdfaWQnLCBwYXJzZUludChzb25nSWQpKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkU29uZ3MgPSBwbGF5bGlzdC5zb25ncy5maWx0ZXIoc29uZyA9PiBzb25nLmlkICE9PSBzb25nSWQpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5wbGF5bGlzdCxcbiAgICAgICAgICAgICAgc29uZ3M6IHVwZGF0ZWRTb25ncyxcbiAgICAgICAgICAgICAgc29uZ0NvdW50OiB1cGRhdGVkU29uZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICBpbWFnZTogdXBkYXRlZFNvbmdzWzBdPy5pbWFnZSB8fCAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbGF5bGlzdFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBzb25nIGZyb20gcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIGxhc3Qgc29uZyBpbiB1c2VyIHByb2ZpbGVcbiAgY29uc3QgdXBkYXRlTGFzdFNvbmcgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAudXBkYXRlKHsgbGFzdF9zb25nX2ZpbGVfaWQ6IHBhcnNlSW50KHNvbmdJZCkgfSlcbiAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBsYXN0IHNvbmc6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVjb3JkIGxpc3RlbmluZyBoaXN0b3J5IHdpdGggcHJvcGVyIHRpbWUgdHJhY2tpbmdcbiAgY29uc3QgcmVjb3JkTGlzdGVuaW5nSGlzdG9yeSA9IGFzeW5jIChzb25nSWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKCF1c2VySWQpIHJldHVyblxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHByZXZpb3VzIHNvbmcgcGxheWluZywgcmVjb3JkIGl0cyBsaXN0ZW5pbmcgdGltZVxuICAgIGlmIChjdXJyZW50U29uZ1JlZi5jdXJyZW50ICYmIGN1cnJlbnRTb25nU3RhcnRUaW1lKSB7XG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG1pbnV0ZXNMaXN0ZW5lZCA9IChlbmRUaW1lLmdldFRpbWUoKSAtIGN1cnJlbnRTb25nU3RhcnRUaW1lLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwKTtcblxuICAgICAgaWYgKG1pbnV0ZXNMaXN0ZW5lZCA+IDAuMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKG1pbnV0ZXNMaXN0ZW5lZCAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCd1cHNlcnRfaGlzdG9yeV9taW51dGVzJywge1xuICAgICAgICAgICAgdXNlcl91dWlkOiB1c2VySWQsXG4gICAgICAgICAgICBzb25nX2ZpbGVfaWQ6IHBhcnNlSW50KGN1cnJlbnRTb25nUmVmLmN1cnJlbnQpLFxuICAgICAgICAgICAgbWludXRlczogbWludXRlcyxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlY29yZGluZyBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEhpc3RvcnkgdXBkYXRlZDogKyR7bWludXRlc30gbWlucyBmb3Igc29uZyAke2N1cnJlbnRTb25nUmVmLmN1cnJlbnR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlY29yZGluZyBwcmV2aW91cyBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IG5ldyBzb25nIGFzIGN1cnJlbnRcbiAgICBjdXJyZW50U29uZ1JlZi5jdXJyZW50ID0gc29uZ0lkXG4gICAgc2V0Q3VycmVudFNvbmdTdGFydFRpbWUobmV3IERhdGUoKSlcbiAgICBcbiAgICAvLyBVcGRhdGUgbGFzdCBzb25nIGluIHVzZXIgcHJvZmlsZVxuICAgIGF3YWl0IHVwZGF0ZUxhc3RTb25nKHNvbmdJZClcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3VwYWJhc2UucnBjKCdpbmNyZW1lbnRfc29uZ192aWV3cycsIHsgc29uZ19maWxlX2lkOiBwYXJzZUludChzb25nSWQpIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbmNyZW1lbnRpbmcgc29uZyB2aWV3czonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RvcCBjdXJyZW50IHNvbmcgdHJhY2tpbmcgKHdoZW4gcGxheWVyIGlzIGNsb3NlZClcbiAgY29uc3Qgc3RvcEN1cnJlbnRTb25nVHJhY2tpbmcgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoY3VycmVudFNvbmdSZWYuY3VycmVudCAmJiBjdXJyZW50U29uZ1N0YXJ0VGltZSAmJiB1c2VySWQpIHtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpXG4gICAgICBjb25zdCBtaW51dGVzTGlzdGVuZWQgPSAoZW5kVGltZS5nZXRUaW1lKCkgLSBjdXJyZW50U29uZ1N0YXJ0VGltZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MClcbiAgICAgIFxuICAgICAgaWYgKG1pbnV0ZXNMaXN0ZW5lZCA+IDAuMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKG1pbnV0ZXNMaXN0ZW5lZCAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCd1cHNlcnRfaGlzdG9yeV9taW51dGVzJywge1xuICAgICAgICAgICAgdXNlcl91dWlkOiB1c2VySWQsXG4gICAgICAgICAgICBzb25nX2ZpbGVfaWQ6IHBhcnNlSW50KGN1cnJlbnRTb25nUmVmLmN1cnJlbnQpLFxuICAgICAgICAgICAgbWludXRlczogbWludXRlcyxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlY29yZGluZyBzb25nIGhpc3Rvcnkgb24gc3RvcDonLCBlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5uRIEhpc3RvcnkgdXBkYXRlZCBvbiBzdG9wOiArJHttaW51dGVzfSBtaW5zIGZvciBzb25nICR7Y3VycmVudFNvbmdSZWYuY3VycmVudH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVjb3JkaW5nIGZpbmFsIHNvbmcgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50U29uZ1JlZi5jdXJyZW50ID0gbnVsbFxuICAgIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lKG51bGwpXG4gIH1cblxuICAvLyBJbml0aWFsaXplIGRhdGEgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ/CfmoAgdXNlU3VwYWJhc2VEYXRhIHVzZUVmZmVjdCB0cmlnZ2VyZWQnKVxuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgY29uc29sZS5sb2coJ/CfkaQgQ3VycmVudCB1c2VySWQgaW4gdXNlRWZmZWN0OicsIHVzZXJJZClcbiAgICBpZiAodXNlcklkKSB7XG4gICAgICBjb25zdCBsb2FkRGF0YVdpdGhSZXRyeSA9IGFzeW5jIChyZXRyeUNvdW50ID0gMCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIExvYWRpbmcgZGF0YSBmb3IgdXNlcjonLCB1c2VySWQpXG4gICAgICAgICAgY29uc29sZS5sb2coYPCflIQgQXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfS8zYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9hZCBzb25ncyBmaXJzdCAobW9zdCBpbXBvcnRhbnQpXG4gICAgICAgICAgYXdhaXQgZmV0Y2hTb25ncygpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVGhlbiBsb2FkIG90aGVyIGRhdGFcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBMb2FkaW5nIGFkZGl0aW9uYWwgZGF0YS4uLicpO1xuICAgICAgICAgIGF3YWl0IGZldGNoUGxheWxpc3RzKClcbiAgICAgICAgICBhd2FpdCBmZXRjaFJlY2VudGx5UGxheWVkKClcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+OiSBBbGwgZGF0YSBsb2FkZWQgc3VjY2Vzc2Z1bGx5IScpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBsb2FkaW5nIGRhdGE6JywgZXJyb3IpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmV0cnkgdXAgdG8gMyB0aW1lcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICBpZiAocmV0cnlDb3VudCA8IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5wb3coMiwgcmV0cnlDb3VudCkgKiAxMDAwOyAvLyAxcywgMnMsIDRzXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4o+zIFJldHJ5aW5nIGluICR7ZGVsYXl9bXMuLi5gKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbG9hZERhdGFXaXRoUmV0cnkocmV0cnlDb3VudCArIDEpLCBkZWxheSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gbG9hZCBkYXRhIGFmdGVyIDMgYXR0ZW1wdHMnKTtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9hZERhdGFXaXRoUmV0cnkoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+aqyBObyB1c2VyIGZvdW5kLCByZXNldHRpbmcgZGF0YScpXG4gICAgICAvLyBSZXNldCBkYXRhIHdoZW4gbm8gdXNlclxuICAgICAgc29uZ3NDYWNoZS5jdXJyZW50ID0gbnVsbFxuICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSBudWxsXG4gICAgICBzZXRTb25ncyhbXSlcbiAgICAgIHNldFBlcnNvbmFsaXplZFNvbmdzKFtdKVxuICAgICAgc2V0VHJlbmRpbmdTb25ncyhbXSlcbiAgICAgIHNldFBsYXlsaXN0cyhbXSlcbiAgICAgIHNldExpa2VkU29uZ3MobmV3IFNldCgpKVxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgIHNldExhc3RQbGF5ZWRTb25nKG51bGwpXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfSwgW10pIC8vIFJlbW92ZSBkZXBlbmRlbmN5IHRvIGF2b2lkIGluZmluaXRlIGxvb3BzXG5cbiAgLy8gQWxzbyBsaXN0ZW4gZm9yIHN0b3JhZ2UgY2hhbmdlcyAod2hlbiB1c2VyIGxvZ3MgaW4vb3V0IGluIGFub3RoZXIgdGFiKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVN0b3JhZ2VDaGFuZ2UgPSAoZTogU3RvcmFnZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09ICd1c2VyX2lkJykge1xuICAgICAgICBjb25zdCB1c2VySWQgPSBlLm5ld1ZhbHVlXG4gICAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBTdG9yYWdlIGNoYW5nZSBkZXRlY3RlZCAtIHVzZXIgbG9nZ2VkIGluOicsIHVzZXJJZClcbiAgICAgICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICAgICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCBmZXRjaFNvbmdzKClcbiAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW2ZldGNoUGxheWxpc3RzKCksIGZldGNoUmVjZW50bHlQbGF5ZWQoKV0pXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgbG9hZGluZyBkYXRhIGFmdGVyIHN0b3JhZ2UgY2hhbmdlOicsIGVycm9yKVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbG9hZERhdGEoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVzZXIgbG9nZ2VkIG91dFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5qqIFN0b3JhZ2UgY2hhbmdlIGRldGVjdGVkIC0gdXNlciBsb2dnZWQgb3V0JylcbiAgICAgICAgICBzb25nc0NhY2hlLmN1cnJlbnQgPSBudWxsXG4gICAgICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSBudWxsXG4gICAgICAgICAgc2V0U29uZ3MoW10pXG4gICAgICAgICAgc2V0UGVyc29uYWxpemVkU29uZ3MoW10pXG4gICAgICAgICAgc2V0VHJlbmRpbmdTb25ncyhbXSlcbiAgICAgICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICAgICAgc2V0TGlrZWRTb25ncyhuZXcgU2V0KCkpXG4gICAgICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgICAgICBzZXRMYXN0UGxheWVkU29uZyhudWxsKVxuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGhhbmRsZVN0b3JhZ2VDaGFuZ2UpXG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgaGFuZGxlU3RvcmFnZUNoYW5nZSlcbiAgfSwgW10pXG5cbiAgLy8gQWRkIGEgc2VwYXJhdGUgZWZmZWN0IHRvIHdhdGNoIGZvciB1c2VyIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjaGVja0FuZExvYWREYXRhID0gKCkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFVzZXIgY2hlY2sgZWZmZWN0IHRyaWdnZXJlZCwgdXNlcklkOicsIHVzZXJJZClcbiAgICAgIGlmICh1c2VySWQgJiYgc29uZ3MubGVuZ3RoID09PSAwICYmICFsb2FkaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFVzZXIgZm91bmQgYnV0IG5vIHNvbmdzIGxvYWRlZCwgbG9hZGluZyBkYXRhLi4uJylcbiAgICAgICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtmZXRjaFNvbmdzKCksIGZldGNoUGxheWxpc3RzKCksIGZldGNoUmVjZW50bHlQbGF5ZWQoKV0pXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZGF0YTonLCBlcnJvcilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9hZERhdGEoKVxuICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FuZExvYWREYXRhKClcbiAgfSwgW3NvbmdzLmxlbmd0aCwgbG9hZGluZ10pXG4gIHJldHVybiB7XG4gICAgc29uZ3MsIC8vIGFsbCBzb25nc1xuICAgIHBlcnNvbmFsaXplZFNvbmdzLCAvLyBzbWFydCBzb3J0ZWQsIGZpbHRlcmVkLCBhbmQgaGlzdG9yeS1leGNsdWRlZCBsaXN0XG4gICAgdHJlbmRpbmdTb25ncywgLy8gdG9wIDE1IHRyZW5kaW5nIGJ5IHZpZXdzK2xpa2VzXG4gICAgcGxheWxpc3RzLFxuICAgIGxpa2VkU29uZ3M6IHNvbmdzLmZpbHRlcihzb25nID0+IHNvbmcuaXNMaWtlZCksXG4gICAgcmVjZW50bHlQbGF5ZWRTb25ncyxcbiAgICBsYXN0UGxheWVkU29uZyxcbiAgICBsb2FkaW5nLFxuICAgIHRvZ2dsZUxpa2UsXG4gICAgY3JlYXRlUGxheWxpc3QsXG4gICAgZGVsZXRlUGxheWxpc3QsXG4gICAgcmVuYW1lUGxheWxpc3QsXG4gICAgYWRkU29uZ1RvUGxheWxpc3QsXG4gICAgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCxcbiAgICByZWNvcmRMaXN0ZW5pbmdIaXN0b3J5LFxuICAgIHN0b3BDdXJyZW50U29uZ1RyYWNraW5nLFxuICAgIHJlZnJlc2hEYXRhOiAoKSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgICAgaWYgKHVzZXJJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBSZWZyZXNoaW5nIGRhdGEuLi4nKVxuICAgICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDbGVhciBjYWNoZXNcbiAgICAgICAgICAgIHNvbmdzQ2FjaGUuY3VycmVudCA9IG51bGxcbiAgICAgICAgICAgIGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50ID0gbnVsbFxuICAgICAgICAgICAgYXdhaXQgZmV0Y2hTb25ncygpXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbZmV0Y2hQbGF5bGlzdHMoKSwgZmV0Y2hSZWNlbnRseVBsYXllZCgpXSlcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlZnJlc2hpbmcgZGF0YTonLCBlcnJvcilcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9hZERhdGEoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGVyc29uYWxpemVkU29uZ3MsXG4gICAgZ2V0U21hcnRQZXJzb25hbGl6ZWRTb25nc1xuICB9XG59Il0sIm5hbWVzIjpbInN1cGFiYXNlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTdXBhYmFzZURhdGEiLCJzb25nc0NhY2hlIiwibGlrZWRTb25nc0NhY2hlIiwic29uZ3MiLCJzZXRTb25ncyIsInBlcnNvbmFsaXplZFNvbmdzIiwic2V0UGVyc29uYWxpemVkU29uZ3MiLCJ0cmVuZGluZ1NvbmdzIiwic2V0VHJlbmRpbmdTb25ncyIsInBsYXlsaXN0cyIsInNldFBsYXlsaXN0cyIsImxpa2VkU29uZ3MiLCJzZXRMaWtlZFNvbmdzIiwiU2V0IiwibGFzdFBsYXllZFNvbmciLCJzZXRMYXN0UGxheWVkU29uZyIsInJlY2VudGx5UGxheWVkU29uZ3MiLCJzZXRSZWNlbnRseVBsYXllZFNvbmdzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjdXJyZW50U29uZ1N0YXJ0VGltZSIsInNldEN1cnJlbnRTb25nU3RhcnRUaW1lIiwiY3VycmVudFNvbmdSZWYiLCJnZXRVc2VySWQiLCJ1c2VySWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwiZ2V0U21hcnRQZXJzb25hbGl6ZWRTb25ncyIsImxpc3RlbmVkU29uZ3NJbkJhdGNoIiwiZXhjbHVkZVNvbmdzIiwibWFwIiwicyIsIm5hbWUiLCJsZW5ndGgiLCJwcmVmZXJyZWRUYWdzIiwicHJlZmVycmVkQXJ0aXN0cyIsImZvckVhY2giLCJzb25nIiwidGFncyIsInRhZyIsImFkZCIsInRvTG93ZXJDYXNlIiwiYXJ0aXN0IiwiQXJyYXkiLCJmcm9tIiwic29uZ3NEYXRhIiwiY3VycmVudCIsImRhdGEiLCJzZWxlY3QiLCJ3YXJuIiwidXNlckxpa2VkU29uZ3MiLCJsaWtlZERhdGEiLCJlcSIsIml0ZW0iLCJzb25nX2lkIiwibGFuZ3VhZ2VGaWx0ZXIiLCJsYW5ndWFnZSIsImF2YWlsYWJsZVNvbmdzIiwiZmlsdGVyIiwiaGFzIiwiZmlsZV9pZCIsInRvU3RyaW5nIiwic2NvcmVkU29uZ3MiLCJzY29yZSIsInNvbmdUYWdzIiwibWF0Y2hpbmdUYWdzIiwibGlzdGVuZWRMYW5ndWFnZXMiLCJpbmNsdWRlcyIsIk1hdGgiLCJsaWtlcyIsInZpZXdzIiwicmFuZG9tIiwiY29udmVydERhdGFiYXNlU29uZyIsInJlY29tbWVuZGF0aW9ucyIsInNvcnQiLCJhIiwiYiIsInNsaWNlIiwiZW50cnkiLCJkYlNvbmciLCJpc0xpa2VkIiwiaW1nX2lkIiwiaWQiLCJpbWFnZSIsImZldGNoU29uZ3MiLCJ0ZXN0RGF0YSIsInRlc3RFcnJvciIsImxpbWl0Iiwic2luZ2xlIiwiRXJyb3IiLCJtZXNzYWdlIiwic2l6ZSIsImhpc3RvcnlEYXRhIiwiaGlzdG9yeUVycm9yIiwib3JkZXIiLCJhc2NlbmRpbmciLCJ0b3BIaXN0b3J5IiwiaCIsInRhZ0NvdW50IiwiYXJ0aXN0Q291bnQiLCJzb25nT2JqIiwiaXNBcnJheSIsInQiLCJjb21tb25UYWdzIiwiT2JqZWN0IiwiZW50cmllcyIsImNvbW1vbkFydGlzdHMiLCJoaXN0b3J5U29uZ0lkcyIsImNvbnZlcnRlZFNvbmdzIiwiZmlsdGVyZWRTb25ncyIsInBlcnNvbmFsaXplZFNvcnRlZCIsInRyZW5kaW5nIiwidXNlckRhdGEiLCJsYXN0X3NvbmdfZmlsZV9pZCIsImxhc3RTb25nIiwiZmluZCIsImdldFBlcnNvbmFsaXplZFNvbmdzIiwiY3VycmVudFNvbmciLCJsaXN0ZW5lZFNvbmdzIiwiaGlzdG9yeU1hcCIsIk1hcCIsInNldCIsIm1pbnV0ZXNfbGlzdGVuZWQiLCJsaXN0ZW5lZE1pbnV0ZXMiLCJnZXQiLCJtaW4iLCJmZXRjaFJlY2VudGx5UGxheWVkIiwicmVjZW50U29uZ3MiLCJmZXRjaFBsYXlsaXN0cyIsInBsYXlsaXN0c0RhdGEiLCJjb252ZXJ0ZWRQbGF5bGlzdHMiLCJwbGF5bGlzdCIsInBsYXlsaXN0U29uZ3MiLCJwbGF5bGlzdF9zb25ncyIsInBzIiwic29uZ0NvdW50IiwidG9nZ2xlTGlrZSIsInNvbmdJZCIsInNvbmdGaWxlSWQiLCJwYXJzZUludCIsImlzQ3VycmVudGx5TGlrZWQiLCJkZWxldGUiLCJycGMiLCJzb25nX2ZpbGVfaWQiLCJwcmV2IiwibmV3U2V0IiwiaW5zZXJ0IiwidXNlcl9pZCIsInByZXZTb25ncyIsInByZXZQbGF5bGlzdHMiLCJjcmVhdGVQbGF5bGlzdCIsIm5ld1BsYXlsaXN0IiwiZGVsZXRlUGxheWxpc3QiLCJwbGF5bGlzdElkIiwicmVuYW1lUGxheWxpc3QiLCJuZXdOYW1lIiwidXBkYXRlIiwiYWRkU29uZ1RvUGxheWxpc3QiLCJwbGF5bGlzdF9pZCIsInNvbmdFeGlzdHMiLCJzb21lIiwidXBkYXRlZFNvbmdzIiwicmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCIsInVwZGF0ZUxhc3RTb25nIiwicmVjb3JkTGlzdGVuaW5nSGlzdG9yeSIsImVuZFRpbWUiLCJEYXRlIiwibWludXRlc0xpc3RlbmVkIiwiZ2V0VGltZSIsIm1pbnV0ZXMiLCJyb3VuZCIsInVzZXJfdXVpZCIsInN0b3BDdXJyZW50U29uZ1RyYWNraW5nIiwibG9hZERhdGFXaXRoUmV0cnkiLCJyZXRyeUNvdW50IiwiZGVsYXkiLCJwb3ciLCJzZXRUaW1lb3V0IiwiaGFuZGxlU3RvcmFnZUNoYW5nZSIsImUiLCJrZXkiLCJuZXdWYWx1ZSIsImxvYWREYXRhIiwiUHJvbWlzZSIsImFsbCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2hlY2tBbmRMb2FkRGF0YSIsInJlZnJlc2hEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});